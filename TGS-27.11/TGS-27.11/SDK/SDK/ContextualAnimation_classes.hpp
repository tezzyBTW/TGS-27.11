#pragma once

/*
* SDK generated by Dumper-8
*
* https://github.com/NotTacs/Dumper-8
*/

// Package: ContextualAnimation

#include "Basic.hpp"

#include "ContextualAnimation_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"


namespace SDK
{

// Class ContextualAnimation.AnimNotifyState_EarlyOutContextualAnimWindow
// 0x0000 (0x0030 - 0x0030)
class UAnimNotifyState_EarlyOutContextualAnimWindow final : public UAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_EarlyOutContextualAnimWindow">();
	}
	static class UAnimNotifyState_EarlyOutContextualAnimWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_EarlyOutContextualAnimWindow>();
	}
};

// Class ContextualAnimation.AnimNotifyState_IKWindow
// 0x0070 (0x00A0 - 0x0030)
class UAnimNotifyState_IKWindow final : public UAnimNotifyState
{
public:
	class FName                                   GoalName;                                          // 0x0030(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-8 ])
	struct FAlphaBlend                            BlendIn;                                           // 0x0038(0x0030)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FAlphaBlend                            BlendOut;                                          // 0x0068(0x0030)(Edit, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEnable;                                           // 0x0098(0x0001)(BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-8 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotifyState_IKWindow">();
	}
	static class UAnimNotifyState_IKWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotifyState_IKWindow>();
	}
};

// Class ContextualAnimation.ContextualAnimActorInterface
// 0x0000 (0x0000 - 0x0000)
class IContextualAnimActorInterface final
{
public:
	class USkeletalMeshComponent* GetMesh() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContextualAnimActorInterface">();
	}
	static class IContextualAnimActorInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IContextualAnimActorInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};

// Class ContextualAnimation.ContextualAnimManager
// 0x0068 (0x0090 - 0x0028)
class UContextualAnimManager final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-8 ])
	TSet<class UContextualAnimSceneActorComponent*> SceneActorCompContainer;                         // 0x0030(0x0050)(ExportObject, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<class UContextualAnimSceneInstance*>   Instances;                                         // 0x0080(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UContextualAnimManager* GetContextualAnimManager(class UObject* WorldContextObject);

	class UContextualAnimSceneInstance* BP_TryStartScene(const class UContextualAnimSceneAsset* SceneAsset, const struct FContextualAnimStartSceneParams& Params_0);
	class UContextualAnimSceneInstance* GetSceneWithActor(class AActor* Actor);
	void OnSceneInstanceEnded(class UContextualAnimSceneInstance* SceneInstance);
	bool TryStopSceneWithActor(class AActor* Actor);

	bool IsActorInAnyScene(class AActor* Actor) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContextualAnimManager">();
	}
	static class UContextualAnimManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContextualAnimManager>();
	}
};

// Class ContextualAnimation.ContextualAnimSceneActorComponent
// 0x0170 (0x06F0 - 0x0580)
class UContextualAnimSceneActorComponent : public UPrimitiveComponent
{
public:
	uint8                                         Pad_578[0x8];                                      // 0x0578(0x0008)(Fixing Size After Last Property [ Dumper-8 ])
	TMulticastInlineDelegate<void(class UContextualAnimSceneActorComponent* SceneActorComponent)> OnJoinedSceneDelegate; // 0x0580(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UContextualAnimSceneActorComponent* SceneActorComponent)> OnLeftSceneDelegate; // 0x0590(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UContextualAnimSceneActorComponent* SceneActorComponent, class FName NotifyName)> OnPlayMontageNotifyBeginDelegate; // 0x05A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UContextualAnimSceneAsset*              SceneAsset;                                        // 0x05B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableDebug;                                      // 0x05B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B9[0x7];                                      // 0x05B9(0x0007)(Fixing Size After Last Property [ Dumper-8 ])
	struct FContextualAnimRepBindingsData         RepBindings;                                       // 0x05C0(0x0050)(Net, Transient, RepNotify, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FContextualAnimRepLateJoinData         RepLateJoinData;                                   // 0x0610(0x0038)(Net, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FContextualAnimRepTransitionData       RepTransitionData;                                 // 0x0648(0x0028)(Net, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FContextualAnimRepTransitionData       RepTransitionSingleActorData;                      // 0x0670(0x0028)(Net, Transient, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FContextualAnimSceneBindings           Bindings;                                          // 0x0698(0x0028)(Transient, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FContextualAnimIKTarget>        IKTargets;                                         // 0x06C0(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_6D0[0x20];                                     // 0x06D0(0x0020)(Fixing Struct Size After Last Property [ Dumper-8 ])

public:
	bool LateJoinContextualAnimScene(class AActor* Actor, class FName Role);
	void OnJoinedScene(const struct FContextualAnimSceneBindings& InBindings);
	void OnLeftScene();
	void OnMontageBlendingOut(class UAnimMontage* Montage, bool bInterrupted);
	void OnPlayMontageNotifyBegin(class FName NotifyName, const struct FBranchingPointNotifyPayload& BranchingPointNotifyPayload);
	void OnRep_Bindings();
	void OnRep_LateJoinData();
	void OnRep_RepTransitionSingleActor();
	void OnRep_TransitionData();
	void OnTickPose(class USkinnedMeshComponent* SkinnedMeshComponent, float DeltaTime, bool bNeedsValidRootMotion);
	void ServerEarlyOutContextualAnimScene();
	void ServerStartContextualAnimScene(const struct FContextualAnimSceneBindings& InBindings);
	bool StartContextualAnimScene(const struct FContextualAnimSceneBindings& InBindings);
	bool TransitionContextualAnimScene(class FName SectionName);
	bool TransitionSingleActor(int32 SectionIdx, int32 AnimSetIdx);

	const struct FContextualAnimIKTarget GetIKTargetByGoalName(class FName GoalName) const;
	const TArray<struct FContextualAnimIKTarget> GetIKTargets() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContextualAnimSceneActorComponent">();
	}
	static class UContextualAnimSceneActorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContextualAnimSceneActorComponent>();
	}
};

// Class ContextualAnimation.ContextualAnimRolesAsset
// 0x0010 (0x0040 - 0x0030)
class UContextualAnimRolesAsset final : public UDataAsset
{
public:
	TArray<struct FContextualAnimRoleDefinition>  Roles;                                             // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContextualAnimRolesAsset">();
	}
	static class UContextualAnimRolesAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContextualAnimRolesAsset>();
	}
};

// Class ContextualAnimation.ContextualAnimSceneAsset
// 0x0060 (0x0090 - 0x0030)
class UContextualAnimSceneAsset final : public UDataAsset
{
public:
	class UContextualAnimRolesAsset*              RolesAsset;                                        // 0x0030(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   PrimaryRole;                                       // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-8 ])
	TArray<struct FContextualAnimActorPreviewData> OverridePreviewData;                              // 0x0040(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FContextualAnimSceneSection>    Sections;                                          // 0x0050(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	float                                         Radius;                                            // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-8 ])
	TSubclassOf<class UContextualAnimSceneInstance> SceneInstanceClass;                              // 0x0068(0x0008)(Edit, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EContextualAnimCollisionBehavior              CollisionBehavior;                                 // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-8 ])
	TArray<struct FContextualAnimIgnoreChannelsParam> CollisionChannelsToIgnoreParams;               // 0x0078(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bPrecomputeAlignmentTracks;                        // 0x0088(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_89[0x3];                                       // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-8 ])
	int32                                         SampleRate;                                        // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UAnimSequenceBase* BP_FindAnimationForRole(int32 SectionIdx, int32 AnimSetIdx, class FName Role) const;
	int32 BP_FindAnimSetIndexByAnimation(int32 SectionIdx, const class UAnimSequenceBase* Animation) const;
	struct FTransform BP_GetAlignmentTransformForRoleRelativeToWarpPoint(int32 SectionIdx, int32 AnimSetIdx, class FName Role, float Time) const;
	struct FTransform BP_GetIKTargetTransformForRoleAtTime(int32 SectionIdx, int32 AnimSetIdx, class FName Role, class FName TrackName, float Time) const;
	void BP_GetStartAndEndTimeForWarpSection(int32 SectionIdx, int32 AnimSetIdx, class FName Role, class FName WarpSectionName, float* OutStartTime, float* OutEndTime) const;
	void GetAlignmentPointsForSecondaryRole(EContextualAnimPointType Type, int32 SectionIdx, const struct FContextualAnimSceneBindingContext& Primary, TArray<struct FContextualAnimPoint>* OutResult) const;
	void GetAlignmentPointsForSecondaryRoleConsideringSelectionCriteria(EContextualAnimPointType Type, int32 SectionIdx, const struct FContextualAnimSceneBindingContext& Primary, const struct FContextualAnimSceneBindingContext& Querier, EContextualAnimCriterionToConsider CriterionToConsider, TArray<struct FContextualAnimPoint>* OutResult) const;
	TArray<class FName> GetRoles() const;
	bool Query(class FName Role, struct FContextualAnimQueryResult* OutResult, const struct FContextualAnimQueryParams& QueryParams, const struct FTransform& ToWorldTransform) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContextualAnimSceneAsset">();
	}
	static class UContextualAnimSceneAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContextualAnimSceneAsset>();
	}
};

// Class ContextualAnimation.ContextualAnimSceneInstance
// 0x00A8 (0x00D0 - 0x0028)
class UContextualAnimSceneInstance final : public UObject
{
public:
	TMulticastInlineDelegate<void(class UContextualAnimSceneInstance* SceneInstance)> OnSectionEndTimeReached; // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UContextualAnimSceneInstance* SceneInstance)> OnSceneEnded;  // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UContextualAnimSceneInstance* SceneInstance, class AActor* Actor)> OnActorJoined; // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UContextualAnimSceneInstance* SceneInstance, class AActor* Actor)> OnActorLeft; // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UContextualAnimSceneInstance* SceneInstance, class AActor* Actor, class FName NotifyName)> OnNotifyBegin; // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMulticastInlineDelegate<void(class UContextualAnimSceneInstance* SceneInstance, class AActor* Actor, class FName NotifyName)> OnNotifyEnd; // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UContextualAnimSceneAsset*              SceneAsset;                                        // 0x0088(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FContextualAnimSceneBindings           Bindings;                                          // 0x0090(0x0028)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Struct Size After Last Property [ Dumper-8 ])

public:
	void OnMontageBlendingOut(class UAnimMontage* Montage, bool bInterrupted);
	void OnNotifyBeginReceived(class FName NotifyName, const struct FBranchingPointNotifyPayload& BranchingPointNotifyPayload);
	void OnNotifyEndReceived(class FName NotifyName, const struct FBranchingPointNotifyPayload& BranchingPointNotifyPayload);

	class AActor* GetActorByRole(class FName Role) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContextualAnimSceneInstance">();
	}
	static class UContextualAnimSceneInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContextualAnimSceneInstance>();
	}
};

// Class ContextualAnimation.ContextualAnimSelectionCriterion
// 0x0008 (0x0030 - 0x0028)
class UContextualAnimSelectionCriterion : public UObject
{
public:
	EContextualAnimCriterionType                  Type;                                              // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-8 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContextualAnimSelectionCriterion">();
	}
	static class UContextualAnimSelectionCriterion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContextualAnimSelectionCriterion>();
	}
};

// Class ContextualAnimation.ContextualAnimSelectionCriterion_Blueprint
// 0x0000 (0x0030 - 0x0030)
class UContextualAnimSelectionCriterion_Blueprint final : public UContextualAnimSelectionCriterion
{
public:
	bool BP_DoesQuerierPassCondition(const struct FContextualAnimSceneBindingContext& Primary, const struct FContextualAnimSceneBindingContext& Querier) const;
	const class UContextualAnimSceneAsset* GetSceneAsset() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContextualAnimSelectionCriterion_Blueprint">();
	}
	static class UContextualAnimSelectionCriterion_Blueprint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContextualAnimSelectionCriterion_Blueprint>();
	}
};

// Class ContextualAnimation.ContextualAnimSelectionCriterion_TriggerArea
// 0x0018 (0x0048 - 0x0030)
class UContextualAnimSelectionCriterion_TriggerArea final : public UContextualAnimSelectionCriterion
{
public:
	TArray<struct FVector>                        PolygonPoints;                                     // 0x0030(0x0010)(Edit, BlueprintVisible, EditFixedSize, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x0040(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-8 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContextualAnimSelectionCriterion_TriggerArea">();
	}
	static class UContextualAnimSelectionCriterion_TriggerArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContextualAnimSelectionCriterion_TriggerArea>();
	}
};

// Class ContextualAnimation.ContextualAnimSelectionCriterion_Cone
// 0x0010 (0x0040 - 0x0030)
class UContextualAnimSelectionCriterion_Cone final : public UContextualAnimSelectionCriterion
{
public:
	EContextualAnimCriterionConeMode              Mode;                                              // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-8 ])
	float                                         Distance;                                          // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HalfAngle;                                         // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Offset;                                            // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContextualAnimSelectionCriterion_Cone">();
	}
	static class UContextualAnimSelectionCriterion_Cone* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContextualAnimSelectionCriterion_Cone>();
	}
};

// Class ContextualAnimation.ContextualAnimSelectionCriterion_Distance
// 0x0010 (0x0040 - 0x0030)
class UContextualAnimSelectionCriterion_Distance final : public UContextualAnimSelectionCriterion
{
public:
	EContextualAnimCriterionDistanceMode          Mode;                                              // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-8 ])
	float                                         MinDistance;                                       // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistance;                                       // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-8 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContextualAnimSelectionCriterion_Distance">();
	}
	static class UContextualAnimSelectionCriterion_Distance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContextualAnimSelectionCriterion_Distance>();
	}
};

// Class ContextualAnimation.ContextualAnimTransition
// 0x0000 (0x0028 - 0x0028)
class UContextualAnimTransition final : public UObject
{
public:
	bool CanEnterTransition(const class UContextualAnimSceneInstance* SceneInstance, const class FName& FromSection, const class FName& ToSection) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContextualAnimTransition">();
	}
	static class UContextualAnimTransition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContextualAnimTransition>();
	}
};

// Class ContextualAnimation.ContextualAnimUtilities
// 0x0000 (0x0028 - 0x0028)
class UContextualAnimUtilities final : public UBlueprintFunctionLibrary
{
public:
	static bool BP_CreateContextualAnimSceneBindings(const class UContextualAnimSceneAsset* SceneAsset, const TMap<class FName, struct FContextualAnimSceneBindingContext>& Params_0, struct FContextualAnimSceneBindings* OutBindings);
	static bool BP_CreateContextualAnimSceneBindingsForTwoActors(const class UContextualAnimSceneAsset* SceneAsset, const struct FContextualAnimSceneBindingContext& Primary, const struct FContextualAnimSceneBindingContext& Secondary, struct FContextualAnimSceneBindings* OutBindings);
	static void BP_DrawDebugPose(const class UObject* WorldContextObject, const class UAnimSequenceBase* Animation, float Time, const struct FTransform& LocalToWorldTransform, const struct FLinearColor& Color, float Lifetime, float Thickness);
	static float BP_Montage_GetSectionLength(const class UAnimMontage* Montage, int32 SectionIndex);
	static void BP_Montage_GetSectionStartAndEndTime(const class UAnimMontage* Montage, int32 SectionIndex, float* OutStartTime, float* OutEndTime);
	static float BP_Montage_GetSectionTimeLeftFromPos(const class UAnimMontage* Montage, float Position);
	static class AActor* BP_SceneBinding_GetActor(const struct FContextualAnimSceneBinding& Binding);
	static const class UAnimSequenceBase* BP_SceneBinding_GetAnimationFromBinding(const struct FContextualAnimSceneBindings& Bindings, const struct FContextualAnimSceneBinding& Binding);
	static class FName BP_SceneBinding_GetRoleFromBinding(const struct FContextualAnimSceneBindings& Bindings, const struct FContextualAnimSceneBinding& Binding);
	static class USkeletalMeshComponent* BP_SceneBinding_GetSkeletalMesh(const struct FContextualAnimSceneBinding& Binding);
	static class AActor* BP_SceneBindingContext_GetActor(const struct FContextualAnimSceneBindingContext& BindingContext);
	static const struct FGameplayTagContainer BP_SceneBindingContext_GetGameplayTags(const struct FContextualAnimSceneBindingContext& BindingContext);
	static struct FTransform BP_SceneBindingContext_GetTransform(const struct FContextualAnimSceneBindingContext& BindingContext);
	static struct FVector BP_SceneBindingContext_GetVelocity(const struct FContextualAnimSceneBindingContext& BindingContext);
	static bool BP_SceneBindingContext_HasAllMatchingGameplayTags(const struct FContextualAnimSceneBindingContext& BindingContext, const struct FGameplayTagContainer& TagContainer);
	static bool BP_SceneBindingContext_HasAnyMatchingGameplayTags(const struct FContextualAnimSceneBindingContext& BindingContext, const struct FGameplayTagContainer& TagContainer);
	static bool BP_SceneBindingContext_HasMatchingGameplayTag(const struct FContextualAnimSceneBindingContext& BindingContext, const struct FGameplayTag& TagToCheck);
	static struct FContextualAnimSceneBindingContext BP_SceneBindingContext_MakeFromActor(class AActor* Actor);
	static struct FContextualAnimSceneBindingContext BP_SceneBindingContext_MakeFromActorWithExternalTransform(class AActor* Actor, const struct FTransform& ExternalTransform);
	static void BP_SceneBindings_AddOrUpdateWarpTargetsForBindings(const struct FContextualAnimSceneBindings& Bindings);
	static void BP_SceneBindings_CalculateWarpPoints(const struct FContextualAnimSceneBindings& Bindings, TArray<struct FContextualAnimWarpPoint>* OutWarpPoints);
	static struct FTransform BP_SceneBindings_GetAlignmentTransformForRoleRelativeToOtherRole(const struct FContextualAnimSceneBindings& Bindings, class FName Role, class FName RelativeToRole, float Time);
	static struct FTransform BP_SceneBindings_GetAlignmentTransformForRoleRelativeToWarpPoint(const struct FContextualAnimSceneBindings& Bindings, class FName Role, const struct FContextualAnimWarpPoint& WarpPoint, float Time);
	static struct FTransform BP_SceneBindings_GetAlignmentTransformFromBinding(const struct FContextualAnimSceneBindings& Bindings, const struct FContextualAnimSceneBinding& Binding, const struct FContextualAnimWarpPoint& WarpPoint);
	static const struct FContextualAnimSceneBinding BP_SceneBindings_GetBindingByActor(const struct FContextualAnimSceneBindings& Bindings, const class AActor* Actor);
	static const struct FContextualAnimSceneBinding BP_SceneBindings_GetBindingByRole(const struct FContextualAnimSceneBindings& Bindings, class FName Role);
	static const TArray<struct FContextualAnimSceneBinding> BP_SceneBindings_GetBindings(const struct FContextualAnimSceneBindings& Bindings);
	static const class UContextualAnimSceneAsset* BP_SceneBindings_GetSceneAsset(const struct FContextualAnimSceneBindings& Bindings);
	static void BP_SceneBindings_GetSectionAndAnimSetIndices(const struct FContextualAnimSceneBindings& Bindings, int32* SectionIdx, int32* AnimSetIdx);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ContextualAnimUtilities">();
	}
	static class UContextualAnimUtilities* GetDefaultObj()
	{
		return GetDefaultObjImpl<UContextualAnimUtilities>();
	}
};

}

