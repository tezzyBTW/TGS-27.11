#pragma once

/*
* SDK generated by Dumper-8
*
* https://github.com/NotTacs/Dumper-8
*/

// Package: VaultingCodeRuntime

#include "Basic.hpp"

#include "VaultingCodeRuntime_classes.hpp"
#include "VaultingCodeRuntime_parameters.hpp"


namespace SDK
{

// Function VaultingCodeRuntime.FortMovementMode_ExtLogicHurdle.BP_GetAnimationMontageInformation
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FSynchedActionInfo&        SynchedActionInfo                                      (Parm, NoDestructor, NativeAccessSpecifierPublic)
// EHurdleType                             Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsNarrowOpening                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsCrouched                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage**                    AnimMontage                                            (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            StartSectionName                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName*                            MontageMiddleSectionName                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFortMovementMode_ExtLogicHurdle::BP_GetAnimationMontageInformation(const struct FSynchedActionInfo& SynchedActionInfo, EHurdleType Type, bool bIsNarrowOpening, bool bIsCrouched, class UAnimMontage** AnimMontage, class FName* StartSectionName, class FName* MontageMiddleSectionName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FortMovementMode_ExtLogicHurdle", "BP_GetAnimationMontageInformation");

	Params::FortMovementMode_ExtLogicHurdle_BP_GetAnimationMontageInformation Parms{};

	Parms.SynchedActionInfo = std::move(SynchedActionInfo);
	Parms.Type = Type;
	Parms.bIsNarrowOpening = bIsNarrowOpening;
	Parms.bIsCrouched = bIsCrouched;

	UObject::ProcessEvent(Func, &Parms);

	if (AnimMontage != nullptr)
		*AnimMontage = Parms.AnimMontage;

	if (StartSectionName != nullptr)
		*StartSectionName = Parms.StartSectionName;

	if (MontageMiddleSectionName != nullptr)
		*MontageMiddleSectionName = Parms.MontageMiddleSectionName;
}


// Function VaultingCodeRuntime.FortMovementMode_ExtLogicHurdle.IsContextualActionPrototypeActive
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UFortMovementMode_ExtLogicHurdle::IsContextualActionPrototypeActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FortMovementMode_ExtLogicHurdle", "IsContextualActionPrototypeActive");

	Params::FortMovementMode_ExtLogicHurdle_IsContextualActionPrototypeActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function VaultingCodeRuntime.HurdleComponent.BP_HandleHurdleEnded
// (Event, Protected, BlueprintEvent)

void UHurdleComponent::BP_HandleHurdleEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HurdleComponent", "BP_HandleHurdleEnded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function VaultingCodeRuntime.HurdleComponent.BP_HandleHurdleStarted
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FHurdleTargetingData&      TargetingData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const struct FSynchedActionInfo&        SynchedActionInfo                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UHurdleComponent::BP_HandleHurdleStarted(const struct FHurdleTargetingData& TargetingData, const struct FSynchedActionInfo& SynchedActionInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HurdleComponent", "BP_HandleHurdleStarted");

	Params::HurdleComponent_BP_HandleHurdleStarted Parms{};

	Parms.TargetingData = std::move(TargetingData);
	Parms.SynchedActionInfo = std::move(SynchedActionInfo);

	UObject::ProcessEvent(Func, &Parms);
}


// Function VaultingCodeRuntime.HurdleComponent.BP_HandleSpringJump
// (Event, Protected, BlueprintEvent)

void UHurdleComponent::BP_HandleSpringJump()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HurdleComponent", "BP_HandleSpringJump");

	UObject::ProcessEvent(Func, nullptr);
}


// Function VaultingCodeRuntime.HurdleComponent.HandleOwnerJumpInput
// (Final, Native, Protected)
// Parameters:
// bool                                    bPressed                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHurdleComponent::HandleOwnerJumpInput(bool bPressed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HurdleComponent", "HandleOwnerJumpInput");

	Params::HurdleComponent_HandleOwnerJumpInput Parms{};

	Parms.bPressed = bPressed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function VaultingCodeRuntime.HurdleComponent.HandleOwnerMovementModeChanged
// (Final, Native, Protected)
// Parameters:
// class ACharacter*                       Character                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMovementMode                           PreviousMovementMode                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   PreviousCustomMode                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHurdleComponent::HandleOwnerMovementModeChanged(class ACharacter* Character, EMovementMode PreviousMovementMode, uint8 PreviousCustomMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HurdleComponent", "HandleOwnerMovementModeChanged");

	Params::HurdleComponent_HandleOwnerMovementModeChanged Parms{};

	Parms.Character = Character;
	Parms.PreviousMovementMode = PreviousMovementMode;
	Parms.PreviousCustomMode = PreviousCustomMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function VaultingCodeRuntime.HurdleComponent.HandleOwnerTeleported
// (Final, Native, Protected)
// Parameters:
// class AFortPawn*                        TeleportedOwner                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHurdleComponent::HandleOwnerTeleported(class AFortPawn* TeleportedOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HurdleComponent", "HandleOwnerTeleported");

	Params::HurdleComponent_HandleOwnerTeleported Parms{};

	Parms.TeleportedOwner = TeleportedOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function VaultingCodeRuntime.HurdleComponent.HandleTargetingDataInvalid
// (Event, Protected, BlueprintEvent)

void UHurdleComponent::HandleTargetingDataInvalid()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HurdleComponent", "HandleTargetingDataInvalid");

	UObject::ProcessEvent(Func, nullptr);
}


// Function VaultingCodeRuntime.HurdleComponent.HandleTargetingDataValid
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FHurdleTargetingData&      TargetingData                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UHurdleComponent::HandleTargetingDataValid(const struct FHurdleTargetingData& TargetingData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HurdleComponent", "HandleTargetingDataValid");

	Params::HurdleComponent_HandleTargetingDataValid Parms{};

	Parms.TargetingData = std::move(TargetingData);

	UObject::ProcessEvent(Func, &Parms);
}


// Function VaultingCodeRuntime.HurdleComponent.OnMutatorUpdated
// (Final, Native, Protected)

void UHurdleComponent::OnMutatorUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HurdleComponent", "OnMutatorUpdated");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function VaultingCodeRuntime.HurdleComponent.OnPlayerStatePawnSet
// (Final, Native, Protected)
// Parameters:
// class APlayerState*                     Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            NewPawn                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            OldPawn                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHurdleComponent::OnPlayerStatePawnSet(class APlayerState* Player, class APawn* NewPawn, class APawn* OldPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HurdleComponent", "OnPlayerStatePawnSet");

	Params::HurdleComponent_OnPlayerStatePawnSet Parms{};

	Parms.Player = Player;
	Parms.NewPawn = NewPawn;
	Parms.OldPawn = OldPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function VaultingCodeRuntime.HurdleComponent.OnRep_ReplicatedHurdleState
// (Final, Native, Protected)

void UHurdleComponent::OnRep_ReplicatedHurdleState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HurdleComponent", "OnRep_ReplicatedHurdleState");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function VaultingCodeRuntime.HurdleComponent.OnRep_ReplicatedLastTeleportTime
// (Final, Native, Protected)

void UHurdleComponent::OnRep_ReplicatedLastTeleportTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HurdleComponent", "OnRep_ReplicatedLastTeleportTime");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function VaultingCodeRuntime.HurdleComponent.RegisterMutatorUpdatedDelegate
// (Final, Native, Protected)
// Parameters:
// class APawn*                            AffectedPawn                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHurdleComponent::RegisterMutatorUpdatedDelegate(class APawn* AffectedPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HurdleComponent", "RegisterMutatorUpdatedDelegate");

	Params::HurdleComponent_RegisterMutatorUpdatedDelegate Parms{};

	Parms.AffectedPawn = AffectedPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function VaultingCodeRuntime.HurdleComponent.ServerStartHurdle
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// const struct FReplicatedHurdleTargetingData&InReplicatedTargetingData                              (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)
// const double                            ClientLastTeleportTime                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHurdleComponent::ServerStartHurdle(const struct FReplicatedHurdleTargetingData& InReplicatedTargetingData, const double ClientLastTeleportTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HurdleComponent", "ServerStartHurdle");

	Params::HurdleComponent_ServerStartHurdle Parms{};

	Parms.InReplicatedTargetingData = std::move(InReplicatedTargetingData);
	Parms.ClientLastTeleportTime = ClientLastTeleportTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function VaultingCodeRuntime.HurdleComponent.UnregisterMutatorUpdatedDelegate
// (Final, Native, Protected)

void UHurdleComponent::UnregisterMutatorUpdatedDelegate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HurdleComponent", "UnregisterMutatorUpdatedDelegate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function VaultingCodeRuntime.HurdleComponent.BP_CanStartHurdle
// (Event, Protected, HasOutParams, BlueprintEvent, Const)
// Parameters:
// bool*                                   OutCanStartHurdle                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHurdleComponent::BP_CanStartHurdle(bool* OutCanStartHurdle) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HurdleComponent", "BP_CanStartHurdle");

	Params::HurdleComponent_BP_CanStartHurdle Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (OutCanStartHurdle != nullptr)
		*OutCanStartHurdle = Parms.OutCanStartHurdle;
}


// Function VaultingCodeRuntime.HurdleComponent.IsContextualActionPrototypeActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHurdleComponent::IsContextualActionPrototypeActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HurdleComponent", "IsContextualActionPrototypeActive");

	Params::HurdleComponent_IsContextualActionPrototypeActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function VaultingCodeRuntime.HurdleComponent.ShouldShowHurdleIndicator
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHurdleComponent::ShouldShowHurdleIndicator() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HurdleComponent", "ShouldShowHurdleIndicator");

	Params::HurdleComponent_ShouldShowHurdleIndicator Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function VaultingCodeRuntime.HurdleLibrary.PerformHurdleTargeting
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class ACharacter*                 Character                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHurdleInputConfigCache*         HurdleInputConfig                                      (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FHurdleTargetingData*            OutTargetingData                                       (Parm, OutParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bIsAutoHurdle                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHurdleLibrary::PerformHurdleTargeting(const class ACharacter* Character, struct FHurdleInputConfigCache* HurdleInputConfig, struct FHurdleTargetingData* OutTargetingData, bool bIsAutoHurdle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("HurdleLibrary", "PerformHurdleTargeting");

	Params::HurdleLibrary_PerformHurdleTargeting Parms{};

	Parms.Character = Character;
	Parms.bIsAutoHurdle = bIsAutoHurdle;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (HurdleInputConfig != nullptr)
		*HurdleInputConfig = std::move(Parms.HurdleInputConfig);

	if (OutTargetingData != nullptr)
		*OutTargetingData = std::move(Parms.OutTargetingData);

	return Parms.ReturnValue;
}

}

