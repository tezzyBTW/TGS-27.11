#pragma once

/*
* SDK generated by Dumper-8
*
* https://github.com/NotTacs/Dumper-8
*/

// Package: AthenaConsumablesSharedFunctionLibrary

#include "Basic.hpp"

#include "AthenaConsumablesSharedFunctionLibrary_classes.hpp"
#include "AthenaConsumablesSharedFunctionLibrary_parameters.hpp"


namespace SDK
{

// Function AthenaConsumablesSharedFunctionLibrary.AthenaConsumablesSharedFunctionLibrary_C.Get Actor Forward Cardinal Direction
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// ECardinalDirection*                     OutCardinalDirection                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double*                                 OutYaw                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAthenaConsumablesSharedFunctionLibrary_C::Get_Actor_Forward_Cardinal_Direction(class AActor* Actor, class UObject* __WorldContext, ECardinalDirection* OutCardinalDirection, double* OutYaw)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AthenaConsumablesSharedFunctionLibrary_C", "Get Actor Forward Cardinal Direction");

	Params::AthenaConsumablesSharedFunctionLibrary_C_Get_Actor_Forward_Cardinal_Direction Parms{};

	Parms.Actor = Actor;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (OutCardinalDirection != nullptr)
		*OutCardinalDirection = Parms.OutCardinalDirection;

	if (OutYaw != nullptr)
		*OutYaw = Parms.OutYaw;
}


// Function AthenaConsumablesSharedFunctionLibrary.AthenaConsumablesSharedFunctionLibrary_C.IsOverlappingDeployableBlockVolume
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// class UObject*                          WorldContextObject                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// float                                   BlockingAreaCheckRadius                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   Location                                               (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool*                                   bOverlapping                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAthenaConsumablesSharedFunctionLibrary_C::IsOverlappingDeployableBlockVolume(class UObject* WorldContextObject, float BlockingAreaCheckRadius, const struct FVector& Location, class UObject* __WorldContext, bool* bOverlapping) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AthenaConsumablesSharedFunctionLibrary_C", "IsOverlappingDeployableBlockVolume");

	Params::AthenaConsumablesSharedFunctionLibrary_C_IsOverlappingDeployableBlockVolume Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.BlockingAreaCheckRadius = BlockingAreaCheckRadius;
	Parms.Location = std::move(Location);
	Parms.__WorldContext = __WorldContext;

	UObject::ProcessEvent(Func, &Parms);

	if (bOverlapping != nullptr)
		*bOverlapping = Parms.bOverlapping;
}

}

