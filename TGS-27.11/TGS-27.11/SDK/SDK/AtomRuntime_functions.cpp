#pragma once

/*
* SDK generated by Dumper-8
*
* https://github.com/NotTacs/Dumper-8
*/

// Package: AtomRuntime

#include "Basic.hpp"

#include "AtomRuntime_classes.hpp"
#include "AtomRuntime_parameters.hpp"


namespace SDK
{

// Function AtomRuntime.AtomPartsCollectionBlueprintLibrary.AddPartInstance
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FAtomModelPartsCollection*       PartCollection                                         (Parm, OutParm, NativeAccessSpecifierPublic)
// const struct FAtomModelPartInstanceInfo&PartInstance                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAtomPartsCollectionBlueprintLibrary::AddPartInstance(struct FAtomModelPartsCollection* PartCollection, const struct FAtomModelPartInstanceInfo& PartInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtomPartsCollectionBlueprintLibrary", "AddPartInstance");

	Params::AtomPartsCollectionBlueprintLibrary_AddPartInstance Parms{};

	Parms.PartInstance = std::move(PartInstance);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (PartCollection != nullptr)
		*PartCollection = std::move(Parms.PartCollection);
}


// Function AtomRuntime.AtomPartsCollectionBlueprintLibrary.CreateColorInfoFromColorId
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ColorId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAtomModelPartColorInfo          ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FAtomModelPartColorInfo UAtomPartsCollectionBlueprintLibrary::CreateColorInfoFromColorId(int32 ColorId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtomPartsCollectionBlueprintLibrary", "CreateColorInfoFromColorId");

	Params::AtomPartsCollectionBlueprintLibrary_CreateColorInfoFromColorId Parms{};

	Parms.ColorId = ColorId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPartsCollectionBlueprintLibrary.FilterGroup
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAtomModel*                       Model                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FAtomModelPartsCollection& PartsCollectionToFilter                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const class FString&                    GroupName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    NewPartsCollectionName                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAtomModelPartsCollection        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FAtomModelPartsCollection UAtomPartsCollectionBlueprintLibrary::FilterGroup(class UAtomModel* Model, const struct FAtomModelPartsCollection& PartsCollectionToFilter, const class FString& GroupName, const class FString& NewPartsCollectionName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtomPartsCollectionBlueprintLibrary", "FilterGroup");

	Params::AtomPartsCollectionBlueprintLibrary_FilterGroup Parms{};

	Parms.Model = Model;
	Parms.PartsCollectionToFilter = std::move(PartsCollectionToFilter);
	Parms.GroupName = std::move(GroupName);
	Parms.NewPartsCollectionName = std::move(NewPartsCollectionName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPartsCollectionBlueprintLibrary.FilterNonTransparent
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FAtomModelPartsCollection& PartsCollectionToFilter                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const class FString&                    NewPartsCollectionName                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAtomModelPartsCollection        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FAtomModelPartsCollection UAtomPartsCollectionBlueprintLibrary::FilterNonTransparent(const struct FAtomModelPartsCollection& PartsCollectionToFilter, const class FString& NewPartsCollectionName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtomPartsCollectionBlueprintLibrary", "FilterNonTransparent");

	Params::AtomPartsCollectionBlueprintLibrary_FilterNonTransparent Parms{};

	Parms.PartsCollectionToFilter = std::move(PartsCollectionToFilter);
	Parms.NewPartsCollectionName = std::move(NewPartsCollectionName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPartsCollectionBlueprintLibrary.FilterSelectionSet
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FAtomModelPartsCollection& PartsCollectionToFilter                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const class FString&                    SelectionSetName                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    NewPartsCollectionName                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAtomModelPartsCollection        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FAtomModelPartsCollection UAtomPartsCollectionBlueprintLibrary::FilterSelectionSet(const struct FAtomModelPartsCollection& PartsCollectionToFilter, const class FString& SelectionSetName, const class FString& NewPartsCollectionName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtomPartsCollectionBlueprintLibrary", "FilterSelectionSet");

	Params::AtomPartsCollectionBlueprintLibrary_FilterSelectionSet Parms{};

	Parms.PartsCollectionToFilter = std::move(PartsCollectionToFilter);
	Parms.SelectionSetName = std::move(SelectionSetName);
	Parms.NewPartsCollectionName = std::move(NewPartsCollectionName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPartsCollectionBlueprintLibrary.FilterTransparent
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FAtomModelPartsCollection& PartsCollectionToFilter                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const class FString&                    NewPartsCollectionName                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAtomModelPartsCollection        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FAtomModelPartsCollection UAtomPartsCollectionBlueprintLibrary::FilterTransparent(const struct FAtomModelPartsCollection& PartsCollectionToFilter, const class FString& NewPartsCollectionName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtomPartsCollectionBlueprintLibrary", "FilterTransparent");

	Params::AtomPartsCollectionBlueprintLibrary_FilterTransparent Parms{};

	Parms.PartsCollectionToFilter = std::move(PartsCollectionToFilter);
	Parms.NewPartsCollectionName = std::move(NewPartsCollectionName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPartsCollectionBlueprintLibrary.GetName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FAtomModelPartsCollection& PartsCollection                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UAtomPartsCollectionBlueprintLibrary::GetName(const struct FAtomModelPartsCollection& PartsCollection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtomPartsCollectionBlueprintLibrary", "GetName");

	Params::AtomPartsCollectionBlueprintLibrary_GetName Parms{};

	Parms.PartsCollection = std::move(PartsCollection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPartsCollectionBlueprintLibrary.GetParts
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FAtomModelPartsCollection& PartsCollection                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<struct FAtomModelPartInstanceInfo>ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<struct FAtomModelPartInstanceInfo> UAtomPartsCollectionBlueprintLibrary::GetParts(const struct FAtomModelPartsCollection& PartsCollection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtomPartsCollectionBlueprintLibrary", "GetParts");

	Params::AtomPartsCollectionBlueprintLibrary_GetParts Parms{};

	Parms.PartsCollection = std::move(PartsCollection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPartsCollectionBlueprintLibrary.InitializeCommonParts
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FAtomModelPartsCollection&       PartsCollection                                        (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const class UAtomModel*                 Model                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRemoveConnectedParts                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRemoveAllKnobs                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRemoveAllTubes                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bRemoveAllPins                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAtomModelPartsCollection        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FAtomModelPartsCollection UAtomPartsCollectionBlueprintLibrary::InitializeCommonParts(struct FAtomModelPartsCollection& PartsCollection, const class UAtomModel* Model, float Scale, bool bRemoveConnectedParts, bool bRemoveAllKnobs, bool bRemoveAllTubes, bool bRemoveAllPins)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtomPartsCollectionBlueprintLibrary", "InitializeCommonParts");

	Params::AtomPartsCollectionBlueprintLibrary_InitializeCommonParts Parms{};

	Parms.PartsCollection = std::move(PartsCollection);
	Parms.Model = Model;
	Parms.Scale = Scale;
	Parms.bRemoveConnectedParts = bRemoveConnectedParts;
	Parms.bRemoveAllKnobs = bRemoveAllKnobs;
	Parms.bRemoveAllTubes = bRemoveAllTubes;
	Parms.bRemoveAllPins = bRemoveAllPins;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	PartsCollection = std::move(Parms.PartsCollection);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPartsCollectionBlueprintLibrary.RemovePartInstance
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FAtomModelPartsCollection*       PartCollection                                         (Parm, OutParm, NativeAccessSpecifierPublic)
// const struct FAtomModelPartGuid&        PartInstanceId                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAtomPartsCollectionBlueprintLibrary::RemovePartInstance(struct FAtomModelPartsCollection* PartCollection, const struct FAtomModelPartGuid& PartInstanceId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtomPartsCollectionBlueprintLibrary", "RemovePartInstance");

	Params::AtomPartsCollectionBlueprintLibrary_RemovePartInstance Parms{};

	Parms.PartInstanceId = std::move(PartInstanceId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (PartCollection != nullptr)
		*PartCollection = std::move(Parms.PartCollection);
}


// Function AtomRuntime.AtomPartsCollectionBlueprintLibrary.ReplacePartInstance
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FAtomModelPartsCollection*       PartCollection                                         (Parm, OutParm, NativeAccessSpecifierPublic)
// const struct FAtomModelPartInstanceInfo&SourcePartInstance                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FAtomModelPartGuid&        TargetPartInstanceId                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAtomPartsCollectionBlueprintLibrary::ReplacePartInstance(struct FAtomModelPartsCollection* PartCollection, const struct FAtomModelPartInstanceInfo& SourcePartInstance, const struct FAtomModelPartGuid& TargetPartInstanceId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtomPartsCollectionBlueprintLibrary", "ReplacePartInstance");

	Params::AtomPartsCollectionBlueprintLibrary_ReplacePartInstance Parms{};

	Parms.SourcePartInstance = std::move(SourcePartInstance);
	Parms.TargetPartInstanceId = std::move(TargetPartInstanceId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (PartCollection != nullptr)
		*PartCollection = std::move(Parms.PartCollection);
}


// Function AtomRuntime.AtomPartsCollectionBlueprintLibrary.SetName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FAtomModelPartsCollection*       PartsCollection                                        (Parm, OutParm, NativeAccessSpecifierPublic)
// const class FString&                    Name_0                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAtomPartsCollectionBlueprintLibrary::SetName(struct FAtomModelPartsCollection* PartsCollection, const class FString& Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtomPartsCollectionBlueprintLibrary", "SetName");

	Params::AtomPartsCollectionBlueprintLibrary_SetName Parms{};

	Parms.Name_0 = std::move(Name_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (PartsCollection != nullptr)
		*PartsCollection = std::move(Parms.PartsCollection);
}


// Function AtomRuntime.AtomPrimitiveBlueprintLibrary.GetDefaultPrimitiveScale
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UAtomPrimitiveBlueprintLibrary::GetDefaultPrimitiveScale()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtomPrimitiveBlueprintLibrary", "GetDefaultPrimitiveScale");

	Params::AtomPrimitiveBlueprintLibrary_GetDefaultPrimitiveScale Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPrimitiveGeometry.CreateAtomGeometryFromCommonPart
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class FString&                    ExportStyleName                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAtomCommonPartType                     CommonPartType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LODIndex                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAtomPrimitiveGeometry*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAtomPrimitiveGeometry* UAtomPrimitiveGeometry::CreateAtomGeometryFromCommonPart(const class FString& ExportStyleName, EAtomCommonPartType CommonPartType, int32 LODIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtomPrimitiveGeometry", "CreateAtomGeometryFromCommonPart");

	Params::AtomPrimitiveGeometry_CreateAtomGeometryFromCommonPart Parms{};

	Parms.ExportStyleName = std::move(ExportStyleName);
	Parms.CommonPartType = CommonPartType;
	Parms.LODIndex = LODIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPrimitiveGeometry.CreateEmptyAtomGeometry
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UAtomPrimitiveGeometry*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAtomPrimitiveGeometry* UAtomPrimitiveGeometry::CreateEmptyAtomGeometry()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtomPrimitiveGeometry", "CreateEmptyAtomGeometry");

	Params::AtomPrimitiveGeometry_CreateEmptyAtomGeometry Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPrimitiveGeometry.GetNumberOfCommonPartLODs
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FString&                    ExportStyleName                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAtomCommonPartType                     CommonPartType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UAtomPrimitiveGeometry::GetNumberOfCommonPartLODs(const class FString& ExportStyleName, EAtomCommonPartType CommonPartType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtomPrimitiveGeometry", "GetNumberOfCommonPartLODs");

	Params::AtomPrimitiveGeometry_GetNumberOfCommonPartLODs Parms{};

	Parms.ExportStyleName = std::move(ExportStyleName);
	Parms.CommonPartType = CommonPartType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPrimitiveGeometry.Append
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class UAtomPrimitiveGeometry*     GeometryToAppend                                       (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform3f&              Transform                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAtomPrimitiveGeometry*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAtomPrimitiveGeometry* UAtomPrimitiveGeometry::Append(const class UAtomPrimitiveGeometry* GeometryToAppend, const struct FTransform3f& Transform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtomPrimitiveGeometry", "Append");

	Params::AtomPrimitiveGeometry_Append Parms{};

	Parms.GeometryToAppend = GeometryToAppend;
	Parms.Transform = std::move(Transform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPrimitiveGeometry.AppendAndWeld
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class UAtomPrimitiveGeometry*     GeometryToAppend                                       (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTransform3f&              Transform                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAtomPrimitiveGeometry*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAtomPrimitiveGeometry* UAtomPrimitiveGeometry::AppendAndWeld(const class UAtomPrimitiveGeometry* GeometryToAppend, const struct FTransform3f& Transform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtomPrimitiveGeometry", "AppendAndWeld");

	Params::AtomPrimitiveGeometry_AppendAndWeld Parms{};

	Parms.GeometryToAppend = GeometryToAppend;
	Parms.Transform = std::move(Transform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPrimitiveGeometry.BakeScale
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAtomPrimitiveGeometry*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAtomPrimitiveGeometry* UAtomPrimitiveGeometry::BakeScale(float Scale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtomPrimitiveGeometry", "BakeScale");

	Params::AtomPrimitiveGeometry_BakeScale Parms{};

	Parms.Scale = Scale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPrimitiveGeometry.BakeTransform
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FTransform3f&              Transform                                              (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAtomPrimitiveGeometry*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAtomPrimitiveGeometry* UAtomPrimitiveGeometry::BakeTransform(const struct FTransform3f& Transform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtomPrimitiveGeometry", "BakeTransform");

	Params::AtomPrimitiveGeometry_BakeTransform Parms{};

	Parms.Transform = std::move(Transform);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPrimitiveGeometry.BakeTransforms
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<struct FTransform3f>&      Transforms                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// class UAtomPrimitiveGeometry*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAtomPrimitiveGeometry* UAtomPrimitiveGeometry::BakeTransforms(const TArray<struct FTransform3f>& Transforms)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtomPrimitiveGeometry", "BakeTransforms");

	Params::AtomPrimitiveGeometry_BakeTransforms Parms{};

	Parms.Transforms = std::move(Transforms);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPrimitiveGeometry.SetMaterialName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const class FString&                    Name_0                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PolygonGroupIndex                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAtomPrimitiveGeometry*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAtomPrimitiveGeometry* UAtomPrimitiveGeometry::SetMaterialName(const class FString& Name_0, int32 PolygonGroupIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtomPrimitiveGeometry", "SetMaterialName");

	Params::AtomPrimitiveGeometry_SetMaterialName Parms{};

	Parms.Name_0 = std::move(Name_0);
	Parms.PolygonGroupIndex = PolygonGroupIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPrimitiveGeometry.SetTiledUVs
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   TileSize                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAtomPrimitiveGeometry*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAtomPrimitiveGeometry* UAtomPrimitiveGeometry::SetTiledUVs(float TileSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtomPrimitiveGeometry", "SetTiledUVs");

	Params::AtomPrimitiveGeometry_SetTiledUVs Parms{};

	Parms.TileSize = TileSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPrimitiveGeometry.SetVertexColor
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FColor&                    Color                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAtomPrimitiveGeometry*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAtomPrimitiveGeometry* UAtomPrimitiveGeometry::SetVertexColor(const struct FColor& Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtomPrimitiveGeometry", "SetVertexColor");

	Params::AtomPrimitiveGeometry_SetVertexColor Parms{};

	Parms.Color = std::move(Color);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPrimitiveGeometry.DuplicateGeometry
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// class UAtomPrimitiveGeometry*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAtomPrimitiveGeometry* UAtomPrimitiveGeometry::DuplicateGeometry() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtomPrimitiveGeometry", "DuplicateGeometry");

	Params::AtomPrimitiveGeometry_DuplicateGeometry Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPrimitiveGeometry.GetMaterialNames
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UAtomPrimitiveGeometry::GetMaterialNames() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtomPrimitiveGeometry", "GetMaterialNames");

	Params::AtomPrimitiveGeometry_GetMaterialNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPrimitiveGeometry.SplitByPolygonGroup
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UAtomPrimitiveGeometry*>   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UAtomPrimitiveGeometry*> UAtomPrimitiveGeometry::SplitByPolygonGroup() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtomPrimitiveGeometry", "SplitByPolygonGroup");

	Params::AtomPrimitiveGeometry_SplitByPolygonGroup Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPrimitiveGeometry.ToSimplifiedStaticMesh
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          Outer_0                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Name_0                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFastBuild                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UStaticMesh*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UStaticMesh* UAtomPrimitiveGeometry::ToSimplifiedStaticMesh(float Scale, class UObject* Outer_0, const class FString& Name_0, bool bFastBuild) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtomPrimitiveGeometry", "ToSimplifiedStaticMesh");

	Params::AtomPrimitiveGeometry_ToSimplifiedStaticMesh Parms{};

	Parms.Scale = Scale;
	Parms.Outer_0 = Outer_0;
	Parms.Name_0 = std::move(Name_0);
	Parms.bFastBuild = bFastBuild;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPrimitiveGeometryContainer.GetCapsGeometry
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FAtomPrimitiveGeometryAndTransform>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FAtomPrimitiveGeometryAndTransform> UAtomPrimitiveGeometryContainer::GetCapsGeometry()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtomPrimitiveGeometryContainer", "GetCapsGeometry");

	Params::AtomPrimitiveGeometryContainer_GetCapsGeometry Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPrimitiveGeometryContainer.GetDetailsGeometry
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FAtomPrimitiveGeometryAndTransform>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FAtomPrimitiveGeometryAndTransform> UAtomPrimitiveGeometryContainer::GetDetailsGeometry()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtomPrimitiveGeometryContainer", "GetDetailsGeometry");

	Params::AtomPrimitiveGeometryContainer_GetDetailsGeometry Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPrimitiveGeometryContainer.GetGeometry
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EPrimitiveGeometryComplexity            PrimitiveGeometryComplexity                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAtomPrimitiveGeometry*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAtomPrimitiveGeometry* UAtomPrimitiveGeometryContainer::GetGeometry(EPrimitiveGeometryComplexity PrimitiveGeometryComplexity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtomPrimitiveGeometryContainer", "GetGeometry");

	Params::AtomPrimitiveGeometryContainer_GetGeometry Parms{};

	Parms.PrimitiveGeometryComplexity = PrimitiveGeometryComplexity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPrimitiveGeometryContainer.GetGeometryWithMaterialNames
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EPrimitiveGeometryComplexity            PrimitiveGeometryComplexity                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    ShellMaterial                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    UndersideMaterial                                      (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAtomPrimitiveGeometry*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAtomPrimitiveGeometry* UAtomPrimitiveGeometryContainer::GetGeometryWithMaterialNames(EPrimitiveGeometryComplexity PrimitiveGeometryComplexity, const class FString& ShellMaterial, const class FString& UndersideMaterial)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtomPrimitiveGeometryContainer", "GetGeometryWithMaterialNames");

	Params::AtomPrimitiveGeometryContainer_GetGeometryWithMaterialNames Parms{};

	Parms.PrimitiveGeometryComplexity = PrimitiveGeometryComplexity;
	Parms.ShellMaterial = std::move(ShellMaterial);
	Parms.UndersideMaterial = std::move(UndersideMaterial);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPrimitiveGeometryContainer.GetPartsGeometry
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FAtomPrimitiveGeometryAndTransform>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FAtomPrimitiveGeometryAndTransform> UAtomPrimitiveGeometryContainer::GetPartsGeometry()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtomPrimitiveGeometryContainer", "GetPartsGeometry");

	Params::AtomPrimitiveGeometryContainer_GetPartsGeometry Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPrimitiveGeometryContainer.GetScaledCapsGeometry
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FAtomPrimitiveGeometryAndTransform>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FAtomPrimitiveGeometryAndTransform> UAtomPrimitiveGeometryContainer::GetScaledCapsGeometry(float Scale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtomPrimitiveGeometryContainer", "GetScaledCapsGeometry");

	Params::AtomPrimitiveGeometryContainer_GetScaledCapsGeometry Parms{};

	Parms.Scale = Scale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPrimitiveGeometryContainer.GetScaledDetailsGeometry
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FAtomPrimitiveGeometryAndTransform>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FAtomPrimitiveGeometryAndTransform> UAtomPrimitiveGeometryContainer::GetScaledDetailsGeometry(float Scale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtomPrimitiveGeometryContainer", "GetScaledDetailsGeometry");

	Params::AtomPrimitiveGeometryContainer_GetScaledDetailsGeometry Parms{};

	Parms.Scale = Scale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPrimitiveGeometryContainer.GetScaledGeometry
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EPrimitiveGeometryComplexity            PrimitiveGeometryComplexity                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAtomPrimitiveGeometry*           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAtomPrimitiveGeometry* UAtomPrimitiveGeometryContainer::GetScaledGeometry(EPrimitiveGeometryComplexity PrimitiveGeometryComplexity, float Scale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtomPrimitiveGeometryContainer", "GetScaledGeometry");

	Params::AtomPrimitiveGeometryContainer_GetScaledGeometry Parms{};

	Parms.PrimitiveGeometryComplexity = PrimitiveGeometryComplexity;
	Parms.Scale = Scale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPrimitiveGeometryContainer.GetScaledShellGeometry
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Scale                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAtomPrimitiveGeometryAndTransformReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FAtomPrimitiveGeometryAndTransform UAtomPrimitiveGeometryContainer::GetScaledShellGeometry(float Scale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtomPrimitiveGeometryContainer", "GetScaledShellGeometry");

	Params::AtomPrimitiveGeometryContainer_GetScaledShellGeometry Parms{};

	Parms.Scale = Scale;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPrimitiveGeometryContainer.GetShellGeometry
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FAtomPrimitiveGeometryAndTransformReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FAtomPrimitiveGeometryAndTransform UAtomPrimitiveGeometryContainer::GetShellGeometry()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtomPrimitiveGeometryContainer", "GetShellGeometry");

	Params::AtomPrimitiveGeometryContainer_GetShellGeometry Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPrimitiveGeometryContainer.GetExportStyleName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UAtomPrimitiveGeometryContainer::GetExportStyleName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtomPrimitiveGeometryContainer", "GetExportStyleName");

	Params::AtomPrimitiveGeometryContainer_GetExportStyleName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomRuntimeBlueprintLibrary.GetAllColorInfo
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TMap<int32, struct FAtomColorInfo>      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<int32, struct FAtomColorInfo> UAtomRuntimeBlueprintLibrary::GetAllColorInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtomRuntimeBlueprintLibrary", "GetAllColorInfo");

	Params::AtomRuntimeBlueprintLibrary_GetAllColorInfo Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomRuntimeBlueprintLibrary.GetBitPackForColor
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FColor&                    Color                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UAtomRuntimeBlueprintLibrary::GetBitPackForColor(const struct FColor& Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtomRuntimeBlueprintLibrary", "GetBitPackForColor");

	Params::AtomRuntimeBlueprintLibrary_GetBitPackForColor Parms{};

	Parms.Color = std::move(Color);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomRuntimeBlueprintLibrary.GetBitPackForColorId
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   AtomColorId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UAtomRuntimeBlueprintLibrary::GetBitPackForColorId(int32 AtomColorId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtomRuntimeBlueprintLibrary", "GetBitPackForColorId");

	Params::AtomRuntimeBlueprintLibrary_GetBitPackForColorId Parms{};

	Parms.AtomColorId = AtomColorId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomRuntimeBlueprintLibrary.GetCommonPartAssetDescriptionFromStaticMesh
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UStaticMesh*                      StaticMesh                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAtomCommonPartAssetDescription* OutDescription                                         (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// EGetCommonPartDescriptionResult*        OutIsValid                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAtomRuntimeBlueprintLibrary::GetCommonPartAssetDescriptionFromStaticMesh(class UStaticMesh* StaticMesh, struct FAtomCommonPartAssetDescription* OutDescription, EGetCommonPartDescriptionResult* OutIsValid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtomRuntimeBlueprintLibrary", "GetCommonPartAssetDescriptionFromStaticMesh");

	Params::AtomRuntimeBlueprintLibrary_GetCommonPartAssetDescriptionFromStaticMesh Parms{};

	Parms.StaticMesh = StaticMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutDescription != nullptr)
		*OutDescription = std::move(Parms.OutDescription);

	if (OutIsValid != nullptr)
		*OutIsValid = Parms.OutIsValid;
}


// Function AtomRuntime.AtomRuntimeBlueprintLibrary.GetCommonPartCategoryFromType
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// EAtomCommonPartType                     CommonPartType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAtomCommonPartCategory                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EAtomCommonPartCategory UAtomRuntimeBlueprintLibrary::GetCommonPartCategoryFromType(EAtomCommonPartType CommonPartType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtomRuntimeBlueprintLibrary", "GetCommonPartCategoryFromType");

	Params::AtomRuntimeBlueprintLibrary_GetCommonPartCategoryFromType Parms{};

	Parms.CommonPartType = CommonPartType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomRuntimeBlueprintLibrary.GetCommonPartDescriptionFromType
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// EAtomCommonPartType                     CommonPartType                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAtomCommonPartDescription*      OutDescription                                         (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UAtomRuntimeBlueprintLibrary::GetCommonPartDescriptionFromType(EAtomCommonPartType CommonPartType, struct FAtomCommonPartDescription* OutDescription)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtomRuntimeBlueprintLibrary", "GetCommonPartDescriptionFromType");

	Params::AtomRuntimeBlueprintLibrary_GetCommonPartDescriptionFromType Parms{};

	Parms.CommonPartType = CommonPartType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutDescription != nullptr)
		*OutDescription = std::move(Parms.OutDescription);
}


// Function AtomRuntime.AtomRuntimeBlueprintLibrary.GetInfoForColorId
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   ColorId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FAtomColorInfo                   ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FAtomColorInfo UAtomRuntimeBlueprintLibrary::GetInfoForColorId(int32 ColorId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtomRuntimeBlueprintLibrary", "GetInfoForColorId");

	Params::AtomRuntimeBlueprintLibrary_GetInfoForColorId Parms{};

	Parms.ColorId = ColorId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomRuntimeSettings.GetColorDataTable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UDataTable*                 ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UDataTable* UAtomRuntimeSettings::GetColorDataTable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtomRuntimeSettings", "GetColorDataTable");

	Params::AtomRuntimeSettings_GetColorDataTable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.WorldConnectivitySubsystem.DisconnectAllObjectConnections
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FWorldConnectivityHandle&  Object                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UWorldConnectivitySubsystem::DisconnectAllObjectConnections(const struct FWorldConnectivityHandle& Object)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldConnectivitySubsystem", "DisconnectAllObjectConnections");

	Params::WorldConnectivitySubsystem_DisconnectAllObjectConnections Parms{};

	Parms.Object = std::move(Object);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AtomRuntime.WorldConnectivitySubsystem.DisconnectObjects
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FWorldConnectivityHandle&  ObjectA                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FWorldConnectivityHandle&  ObjectB                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)

void UWorldConnectivitySubsystem::DisconnectObjects(const struct FWorldConnectivityHandle& ObjectA, const struct FWorldConnectivityHandle& ObjectB)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldConnectivitySubsystem", "DisconnectObjects");

	Params::WorldConnectivitySubsystem_DisconnectObjects Parms{};

	Parms.ObjectA = std::move(ObjectA);
	Parms.ObjectB = std::move(ObjectB);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AtomRuntime.WorldConnectivitySubsystem.GetAtomModelAssetUserData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAtomModelAssetUserData*          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAtomModelAssetUserData* UWorldConnectivitySubsystem::GetAtomModelAssetUserData(class UObject* Object)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldConnectivitySubsystem", "GetAtomModelAssetUserData");

	Params::WorldConnectivitySubsystem_GetAtomModelAssetUserData Parms{};

	Parms.Object = Object;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.WorldConnectivitySubsystem.GetClosestFieldToPoint
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FWorldConnectivityHandle&  Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FVector&                   WorldLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EConnectionFieldGender                  Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bSuccess                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPlanarFieldInfo                 ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FPlanarFieldInfo UWorldConnectivitySubsystem::GetClosestFieldToPoint(const struct FWorldConnectivityHandle& Handle, const struct FVector& WorldLocation, EConnectionFieldGender Type, bool* bSuccess)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldConnectivitySubsystem", "GetClosestFieldToPoint");

	Params::WorldConnectivitySubsystem_GetClosestFieldToPoint Parms{};

	Parms.Handle = std::move(Handle);
	Parms.WorldLocation = std::move(WorldLocation);
	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bSuccess != nullptr)
		*bSuccess = Parms.bSuccess;

	return Parms.ReturnValue;
}


// Function AtomRuntime.WorldConnectivitySubsystem.GetConnectedObjects
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FWorldConnectivityHandle&  Object                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<struct FWorldConnectivityHandle> ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FWorldConnectivityHandle> UWorldConnectivitySubsystem::GetConnectedObjects(const struct FWorldConnectivityHandle& Object)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldConnectivitySubsystem", "GetConnectedObjects");

	Params::WorldConnectivitySubsystem_GetConnectedObjects Parms{};

	Parms.Object = std::move(Object);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.WorldConnectivitySubsystem.GetConnectedObjectsRecursively
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FWorldConnectivityHandle&  Object                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<struct FWorldConnectivityHandle> ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FWorldConnectivityHandle> UWorldConnectivitySubsystem::GetConnectedObjectsRecursively(const struct FWorldConnectivityHandle& Object)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldConnectivitySubsystem", "GetConnectedObjectsRecursively");

	Params::WorldConnectivitySubsystem_GetConnectedObjectsRecursively Parms{};

	Parms.Object = std::move(Object);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.WorldConnectivitySubsystem.GetOverlapPenetrationDepth
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class AStaticMeshActor*                 Actor1                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AStaticMeshActor*                 Actor2                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Offset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UWorldConnectivitySubsystem::GetOverlapPenetrationDepth(class AStaticMeshActor* Actor1, class AStaticMeshActor* Actor2, const struct FVector& Offset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldConnectivitySubsystem", "GetOverlapPenetrationDepth");

	Params::WorldConnectivitySubsystem_GetOverlapPenetrationDepth Parms{};

	Parms.Actor1 = Actor1;
	Parms.Actor2 = Actor2;
	Parms.Offset = std::move(Offset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.WorldConnectivitySubsystem.GetPlanarFields
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FWorldConnectivityHandle&  Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// EConnectionFieldGender                  Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FPlanarFieldInfo>         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FPlanarFieldInfo> UWorldConnectivitySubsystem::GetPlanarFields(const struct FWorldConnectivityHandle& Handle, EConnectionFieldGender Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldConnectivitySubsystem", "GetPlanarFields");

	Params::WorldConnectivitySubsystem_GetPlanarFields Parms{};

	Parms.Handle = std::move(Handle);
	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.WorldConnectivitySubsystem.RegisterConnectivityActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UAtomModel*                 Model                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWorldConnectivitySubsystem::RegisterConnectivityActor(class AActor* Actor, const class UAtomModel* Model)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldConnectivitySubsystem", "RegisterConnectivityActor");

	Params::WorldConnectivitySubsystem_RegisterConnectivityActor Parms{};

	Parms.Actor = Actor;
	Parms.Model = Model;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AtomRuntime.WorldConnectivitySubsystem.RegisterCustomConnectivityActor
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FSerializedConnectivityObjects&ConnectivityObject                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UWorldConnectivitySubsystem::RegisterCustomConnectivityActor(class AActor* Actor, const struct FSerializedConnectivityObjects& ConnectivityObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldConnectivitySubsystem", "RegisterCustomConnectivityActor");

	Params::WorldConnectivitySubsystem_RegisterCustomConnectivityActor Parms{};

	Parms.Actor = Actor;
	Parms.ConnectivityObject = std::move(ConnectivityObject);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AtomRuntime.WorldConnectivitySubsystem.RegisterModelActor
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FSerializedConnectivityObjects&Connections                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UWorldConnectivitySubsystem::RegisterModelActor(class AActor* Actor, const struct FSerializedConnectivityObjects& Connections)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldConnectivitySubsystem", "RegisterModelActor");

	Params::WorldConnectivitySubsystem_RegisterModelActor Parms{};

	Parms.Actor = Actor;
	Parms.Connections = std::move(Connections);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AtomRuntime.WorldConnectivitySubsystem.ReleaseConnectivityActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWorldConnectivitySubsystem::ReleaseConnectivityActor(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldConnectivitySubsystem", "ReleaseConnectivityActor");

	Params::WorldConnectivitySubsystem_ReleaseConnectivityActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AtomRuntime.WorldConnectivitySubsystem.TryConnectObjectAtLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FWorldConnectivityHandle&  ObjectToConnect                                        (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FTransform&                DesiredObjectTransform                                 (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FWorldConnectivityHandle>&ConnectionCandidates                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    PerformConnection                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWorldConnectivitySubsystem::TryConnectObjectAtLocation(const struct FWorldConnectivityHandle& ObjectToConnect, const struct FTransform& DesiredObjectTransform, const TArray<struct FWorldConnectivityHandle>& ConnectionCandidates, bool PerformConnection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldConnectivitySubsystem", "TryConnectObjectAtLocation");

	Params::WorldConnectivitySubsystem_TryConnectObjectAtLocation Parms{};

	Parms.ObjectToConnect = std::move(ObjectToConnect);
	Parms.DesiredObjectTransform = std::move(DesiredObjectTransform);
	Parms.ConnectionCandidates = std::move(ConnectionCandidates);
	Parms.PerformConnection = PerformConnection;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.WorldConnectivitySubsystem.GetActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FWorldConnectivityHandle&  Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UWorldConnectivitySubsystem::GetActor(const struct FWorldConnectivityHandle& Handle) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldConnectivitySubsystem", "GetActor");

	Params::WorldConnectivitySubsystem_GetActor Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.WorldConnectivitySubsystem.GetConnectivityHandle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FWorldConnectivityHandle         ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FWorldConnectivityHandle UWorldConnectivitySubsystem::GetConnectivityHandle(class AActor* Actor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldConnectivitySubsystem", "GetConnectivityHandle");

	Params::WorldConnectivitySubsystem_GetConnectivityHandle Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.WorldConnectivitySubsystem.GetTransform
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FWorldConnectivityHandle&  Handle                                                 (Parm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FTransform                 ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FTransform UWorldConnectivitySubsystem::GetTransform(const struct FWorldConnectivityHandle& Handle) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldConnectivitySubsystem", "GetTransform");

	Params::WorldConnectivitySubsystem_GetTransform Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.WorldConnectivitySubsystem.PlanarGridStepSize
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

double UWorldConnectivitySubsystem::PlanarGridStepSize() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WorldConnectivitySubsystem", "PlanarGridStepSize");

	Params::WorldConnectivitySubsystem_PlanarGridStepSize Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.WorldConnectivityBlueprintLibrary.GetActor
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FWorldConnectivityHandle&  Handle                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UWorldConnectivityBlueprintLibrary::GetActor(class UObject* WorldContext, const struct FWorldConnectivityHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("WorldConnectivityBlueprintLibrary", "GetActor");

	Params::WorldConnectivityBlueprintLibrary_GetActor Parms{};

	Parms.WorldContext = WorldContext;
	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.WorldConnectivityBlueprintLibrary.GetFieldCenter
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FPlanarFieldInfo&          Field                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UWorldConnectivityBlueprintLibrary::GetFieldCenter(const struct FPlanarFieldInfo& Field)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("WorldConnectivityBlueprintLibrary", "GetFieldCenter");

	Params::WorldConnectivityBlueprintLibrary_GetFieldCenter Parms{};

	Parms.Field = std::move(Field);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.WorldConnectivityBlueprintLibrary.GetTransform
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FWorldConnectivityHandle&  Handle                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTransform UWorldConnectivityBlueprintLibrary::GetTransform(class UObject* WorldContext, const struct FWorldConnectivityHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("WorldConnectivityBlueprintLibrary", "GetTransform");

	Params::WorldConnectivityBlueprintLibrary_GetTransform Parms{};

	Parms.WorldContext = WorldContext;
	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.WorldConnectivityBlueprintLibrary.IsValid
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FWorldConnectivityHandle&  Handle                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWorldConnectivityBlueprintLibrary::IsValid(const struct FWorldConnectivityHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("WorldConnectivityBlueprintLibrary", "IsValid");

	Params::WorldConnectivityBlueprintLibrary_IsValid Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomModel.GetChildIdentifier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InChildIdx                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UAtomModel::GetChildIdentifier(int32 InChildIdx)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtomModel", "GetChildIdentifier");

	Params::AtomModel_GetChildIdentifier Parms{};

	Parms.InChildIdx = InChildIdx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomModel.GetPrimitivesForChildArray
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   InChildIdx                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FAtomModelPrimitiveInstance>*OutPrimitives                                          (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void UAtomModel::GetPrimitivesForChildArray(int32 InChildIdx, TArray<struct FAtomModelPrimitiveInstance>* OutPrimitives)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtomModel", "GetPrimitivesForChildArray");

	Params::AtomModel_GetPrimitivesForChildArray Parms{};

	Parms.InChildIdx = InChildIdx;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutPrimitives != nullptr)
		*OutPrimitives = std::move(Parms.OutPrimitives);
}


// Function AtomRuntime.AtomModel.GetGeneratedMergedMeshes
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<TSoftObjectPtr<class UStaticMesh>>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, UObjectWrapper, NativeAccessSpecifierPublic)

TArray<TSoftObjectPtr<class UStaticMesh>> UAtomModel::GetGeneratedMergedMeshes() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtomModel", "GetGeneratedMergedMeshes");

	Params::AtomModel_GetGeneratedMergedMeshes Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomModel.GetModelName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UAtomModel::GetModelName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtomModel", "GetModelName");

	Params::AtomModel_GetModelName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomModel.GetModelPath
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UAtomModel::GetModelPath() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtomModel", "GetModelPath");

	Params::AtomModel_GetModelPath Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomModel.GetPartsCollection
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FAtomModelPartsCollection        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FAtomModelPartsCollection UAtomModel::GetPartsCollection() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtomModel", "GetPartsCollection");

	Params::AtomModel_GetPartsCollection Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomModel.GetTextureForDecorationTextureName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FString&                    TextureName                                            (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UTexture*                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture* UAtomModel::GetTextureForDecorationTextureName(const class FString& TextureName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtomModel", "GetTextureForDecorationTextureName");

	Params::AtomModel_GetTextureForDecorationTextureName Parms{};

	Parms.TextureName = std::move(TextureName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomModelProcessor.IncrementProgress
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NumSteps                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    Message                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAtomModelProcessor::IncrementProgress(int32 NumSteps, const class FString& Message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtomModelProcessor", "IncrementProgress");

	Params::AtomModelProcessor_IncrementProgress Parms{};

	Parms.NumSteps = NumSteps;
	Parms.Message = std::move(Message);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function AtomRuntime.AtomModelProcessor.OnGetTargetAssetPath
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class UAtomModel*                       Model                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAtomPrimitive*                   Primitive                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FAtomModelPartsCollection& AtomModelPartsCollection                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UAtomModelProcessor::OnGetTargetAssetPath(class UAtomModel* Model, class UAtomPrimitive* Primitive, const struct FAtomModelPartsCollection& AtomModelPartsCollection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtomModelProcessor", "OnGetTargetAssetPath");

	Params::AtomModelProcessor_OnGetTargetAssetPath Parms{};

	Parms.Model = Model;
	Parms.Primitive = Primitive;
	Parms.AtomModelPartsCollection = std::move(AtomModelPartsCollection);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomModelProcessor.OnProcessModel
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class UAtomModel*                       Model                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FAtomModelPartsCollection& AtomModelPartsCollection                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<TSoftObjectPtr<class UObject>>&ExistingObjects                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, UObjectWrapper, NativeAccessSpecifierPublic)
// struct FAtomProcessorResult             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FAtomProcessorResult UAtomModelProcessor::OnProcessModel(class UAtomModel* Model, const struct FAtomModelPartsCollection& AtomModelPartsCollection, const TArray<TSoftObjectPtr<class UObject>>& ExistingObjects)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtomModelProcessor", "OnProcessModel");

	Params::AtomModelProcessor_OnProcessModel Parms{};

	Parms.Model = Model;
	Parms.AtomModelPartsCollection = std::move(AtomModelPartsCollection);
	Parms.ExistingObjects = std::move(ExistingObjects);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomModelProcessor.OnProcessPrimitive
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class UAtomModel*                       DummyModel                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAtomPrimitive*                   Primitive                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FAtomModelPartsCollection& AtomModelPartsCollection                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FAtomProcessorResult             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FAtomProcessorResult UAtomModelProcessor::OnProcessPrimitive(class UAtomModel* DummyModel, class UAtomPrimitive* Primitive, const struct FAtomModelPartsCollection& AtomModelPartsCollection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtomModelProcessor", "OnProcessPrimitive");

	Params::AtomModelProcessor_OnProcessPrimitive Parms{};

	Parms.DummyModel = DummyModel;
	Parms.Primitive = Primitive;
	Parms.AtomModelPartsCollection = std::move(AtomModelPartsCollection);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomProcessorBlueprintLibrary.AppendAtomProcessorResult
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FAtomProcessorResult&      Result                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FAtomProcessorResult&      ResultToAppend                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FAtomProcessorResult             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FAtomProcessorResult UAtomProcessorBlueprintLibrary::AppendAtomProcessorResult(const struct FAtomProcessorResult& Result, const struct FAtomProcessorResult& ResultToAppend)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtomProcessorBlueprintLibrary", "AppendAtomProcessorResult");

	Params::AtomProcessorBlueprintLibrary_AppendAtomProcessorResult Parms{};

	Parms.Result = std::move(Result);
	Parms.ResultToAppend = std::move(ResultToAppend);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomProcessorBlueprintLibrary.GetModelProcessor
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FAtomModelProcessorInstance&ProcessorInstance                                      (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const class UAtomModelProcessor*        ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UAtomModelProcessor* UAtomProcessorBlueprintLibrary::GetModelProcessor(const struct FAtomModelProcessorInstance& ProcessorInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtomProcessorBlueprintLibrary", "GetModelProcessor");

	Params::AtomProcessorBlueprintLibrary_GetModelProcessor Parms{};

	Parms.ProcessorInstance = std::move(ProcessorInstance);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomProcessorBlueprintLibrary.GetProcessorClass
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FAtomModelProcessorInstance&ProcessorInstance                                      (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const class UClass*                     ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UClass* UAtomProcessorBlueprintLibrary::GetProcessorClass(const struct FAtomModelProcessorInstance& ProcessorInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtomProcessorBlueprintLibrary", "GetProcessorClass");

	Params::AtomProcessorBlueprintLibrary_GetProcessorClass Parms{};

	Parms.ProcessorInstance = std::move(ProcessorInstance);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomProcessorBlueprintLibrary.IsValid
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FAtomModelProcessorInstance&ProcessorInstance                                      (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAtomProcessorBlueprintLibrary::IsValid(const struct FAtomModelProcessorInstance& ProcessorInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtomProcessorBlueprintLibrary", "IsValid");

	Params::AtomProcessorBlueprintLibrary_IsValid Parms{};

	Parms.ProcessorInstance = std::move(ProcessorInstance);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomProcessorBlueprintLibrary.SetModelProcessor
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FAtomModelProcessorInstance&     ProcessorInstance                                      (Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// class UAtomModelProcessor*              ModelProcessor                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUseCustomSettings                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAtomProcessorBlueprintLibrary::SetModelProcessor(struct FAtomModelProcessorInstance& ProcessorInstance, class UAtomModelProcessor* ModelProcessor, bool bUseCustomSettings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtomProcessorBlueprintLibrary", "SetModelProcessor");

	Params::AtomProcessorBlueprintLibrary_SetModelProcessor Parms{};

	Parms.ProcessorInstance = std::move(ProcessorInstance);
	Parms.ModelProcessor = ModelProcessor;
	Parms.bUseCustomSettings = bUseCustomSettings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	ProcessorInstance = std::move(Parms.ProcessorInstance);
}


// Function AtomRuntime.AtomPrimitive.GetMainGroupName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   MainGroupId                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UAtomPrimitive::GetMainGroupName(int32 MainGroupId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtomPrimitive", "GetMainGroupName");

	Params::AtomPrimitive_GetMainGroupName Parms{};

	Parms.MainGroupId = MainGroupId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPrimitive.GetSubMainGroupName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// int32                                   SubMainGroupId                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UAtomPrimitive::GetSubMainGroupName(int32 SubMainGroupId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AtomPrimitive", "GetSubMainGroupName");

	Params::AtomPrimitive_GetSubMainGroupName Parms{};

	Parms.SubMainGroupId = SubMainGroupId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPrimitive.GetGeometryContainerForExportStyle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class FString&                    ExportStyleName                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FString&                    FallbackExportStyleName                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAtomPrimitiveGeometryContainer*  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAtomPrimitiveGeometryContainer* UAtomPrimitive::GetGeometryContainerForExportStyle(const class FString& ExportStyleName, const class FString& FallbackExportStyleName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtomPrimitive", "GetGeometryContainerForExportStyle");

	Params::AtomPrimitive_GetGeometryContainerForExportStyle Parms{};

	Parms.ExportStyleName = std::move(ExportStyleName);
	Parms.FallbackExportStyleName = std::move(FallbackExportStyleName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function AtomRuntime.AtomPrimitive.IsFlexElement
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAtomPrimitive::IsFlexElement() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AtomPrimitive", "IsFlexElement");

	Params::AtomPrimitive_IsFlexElement Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}

}

