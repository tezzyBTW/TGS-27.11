#pragma once

/*
* SDK generated by Dumper-8
*
* https://github.com/NotTacs/Dumper-8
*/

// Package: PoseSearch

#include "Basic.hpp"

#include "PoseSearch_classes.hpp"
#include "PoseSearch_parameters.hpp"


namespace SDK
{

// Function PoseSearch.MotionMatchingAnimNodeLibrary.ConvertToMotionMatchingNode
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FAnimNodeReference&        Node                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// EAnimNodeReferenceConversionResult*     Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMotionMatchingAnimNodeReference ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FMotionMatchingAnimNodeReference UMotionMatchingAnimNodeLibrary::ConvertToMotionMatchingNode(const struct FAnimNodeReference& Node, EAnimNodeReferenceConversionResult* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MotionMatchingAnimNodeLibrary", "ConvertToMotionMatchingNode");

	Params::MotionMatchingAnimNodeLibrary_ConvertToMotionMatchingNode Parms{};

	Parms.Node = std::move(Node);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;

	return Parms.ReturnValue;
}


// Function PoseSearch.MotionMatchingAnimNodeLibrary.ConvertToMotionMatchingNodePure
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FAnimNodeReference&        Node                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FMotionMatchingAnimNodeReference*MotionMatchingNode                                     (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// bool*                                   Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMotionMatchingAnimNodeLibrary::ConvertToMotionMatchingNodePure(const struct FAnimNodeReference& Node, struct FMotionMatchingAnimNodeReference* MotionMatchingNode, bool* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MotionMatchingAnimNodeLibrary", "ConvertToMotionMatchingNodePure");

	Params::MotionMatchingAnimNodeLibrary_ConvertToMotionMatchingNodePure Parms{};

	Parms.Node = std::move(Node);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (MotionMatchingNode != nullptr)
		*MotionMatchingNode = std::move(Parms.MotionMatchingNode);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function PoseSearch.MotionMatchingAnimNodeLibrary.ForceInterruptNextUpdate
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FMotionMatchingAnimNodeReference&MotionMatchingNode                                     (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UMotionMatchingAnimNodeLibrary::ForceInterruptNextUpdate(const struct FMotionMatchingAnimNodeReference& MotionMatchingNode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MotionMatchingAnimNodeLibrary", "ForceInterruptNextUpdate");

	Params::MotionMatchingAnimNodeLibrary_ForceInterruptNextUpdate Parms{};

	Parms.MotionMatchingNode = std::move(MotionMatchingNode);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function PoseSearch.MotionMatchingAnimNodeLibrary.GetMotionMatchingSearchResult
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// const struct FMotionMatchingAnimNodeReference&MotionMatchingNode                                     (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FPoseSearchBlueprintResult*      Result                                                 (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// bool*                                   bIsResultValid                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMotionMatchingAnimNodeLibrary::GetMotionMatchingSearchResult(const struct FMotionMatchingAnimNodeReference& MotionMatchingNode, struct FPoseSearchBlueprintResult* Result, bool* bIsResultValid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MotionMatchingAnimNodeLibrary", "GetMotionMatchingSearchResult");

	Params::MotionMatchingAnimNodeLibrary_GetMotionMatchingSearchResult Parms{};

	Parms.MotionMatchingNode = std::move(MotionMatchingNode);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = std::move(Parms.Result);

	if (bIsResultValid != nullptr)
		*bIsResultValid = Parms.bIsResultValid;
}


// Function PoseSearch.MotionMatchingAnimNodeLibrary.ResetDatabasesToSearch
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FMotionMatchingAnimNodeReference&MotionMatchingNode                                     (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    bForceInterrupt                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMotionMatchingAnimNodeLibrary::ResetDatabasesToSearch(const struct FMotionMatchingAnimNodeReference& MotionMatchingNode, bool bForceInterrupt)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MotionMatchingAnimNodeLibrary", "ResetDatabasesToSearch");

	Params::MotionMatchingAnimNodeLibrary_ResetDatabasesToSearch Parms{};

	Parms.MotionMatchingNode = std::move(MotionMatchingNode);
	Parms.bForceInterrupt = bForceInterrupt;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function PoseSearch.MotionMatchingAnimNodeLibrary.SetDatabasesToSearch
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FMotionMatchingAnimNodeReference&MotionMatchingNode                                     (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const TArray<class UPoseSearchDatabase*>&Databases                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bForceInterruptIfNew                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMotionMatchingAnimNodeLibrary::SetDatabasesToSearch(const struct FMotionMatchingAnimNodeReference& MotionMatchingNode, const TArray<class UPoseSearchDatabase*>& Databases, bool bForceInterruptIfNew)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MotionMatchingAnimNodeLibrary", "SetDatabasesToSearch");

	Params::MotionMatchingAnimNodeLibrary_SetDatabasesToSearch Parms{};

	Parms.MotionMatchingNode = std::move(MotionMatchingNode);
	Parms.Databases = std::move(Databases);
	Parms.bForceInterruptIfNew = bForceInterruptIfNew;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function PoseSearch.MotionMatchingAnimNodeLibrary.SetDatabaseToSearch
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FMotionMatchingAnimNodeReference&MotionMatchingNode                                     (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class UPoseSearchDatabase*              Database                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForceInterruptIfNew                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMotionMatchingAnimNodeLibrary::SetDatabaseToSearch(const struct FMotionMatchingAnimNodeReference& MotionMatchingNode, class UPoseSearchDatabase* Database, bool bForceInterruptIfNew)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MotionMatchingAnimNodeLibrary", "SetDatabaseToSearch");

	Params::MotionMatchingAnimNodeLibrary_SetDatabaseToSearch Parms{};

	Parms.MotionMatchingNode = std::move(MotionMatchingNode);
	Parms.Database = Database;
	Parms.bForceInterruptIfNew = bForceInterruptIfNew;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function PoseSearch.PoseSearchFeatureChannel_Heading.BP_GetWorldRotation
// (Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class UAnimInstance*              AnimInstance                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FQuat                            ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FQuat UPoseSearchFeatureChannel_Heading::BP_GetWorldRotation(const class UAnimInstance* AnimInstance) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PoseSearchFeatureChannel_Heading", "BP_GetWorldRotation");

	Params::PoseSearchFeatureChannel_Heading_BP_GetWorldRotation Parms{};

	Parms.AnimInstance = AnimInstance;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function PoseSearch.PoseSearchFeatureChannel_Position.BP_GetWorldPosition
// (Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class UAnimInstance*              AnimInstance                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UPoseSearchFeatureChannel_Position::BP_GetWorldPosition(const class UAnimInstance* AnimInstance) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PoseSearchFeatureChannel_Position", "BP_GetWorldPosition");

	Params::PoseSearchFeatureChannel_Position_BP_GetWorldPosition Parms{};

	Parms.AnimInstance = AnimInstance;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function PoseSearch.PoseSearchFeatureChannel_Velocity.BP_GetWorldVelocity
// (Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class UAnimInstance*              AnimInstance                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UPoseSearchFeatureChannel_Velocity::BP_GetWorldVelocity(const class UAnimInstance* AnimInstance) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PoseSearchFeatureChannel_Velocity", "BP_GetWorldVelocity");

	Params::PoseSearchFeatureChannel_Velocity_BP_GetWorldVelocity Parms{};

	Parms.AnimInstance = AnimInstance;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function PoseSearch.PoseSearchLibrary.MotionMatch
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UAnimInstance*                    AnimInstance                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UPoseSearchDatabase*        Database                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FPoseSearchQueryTrajectory&Trajectory                                             (ConstParm, Parm, NativeAccessSpecifierPublic)
// float                                   TrajectorySpeedMultiplier                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       PoseHistoryName                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPoseSearchBlueprintResult*      Result                                                 (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// const class UAnimationAsset*            FutureAnimation                                        (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FutureAnimationStartTime                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TimeToFutureAnimationStart                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             DebugSessionUniqueIdentifier                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPoseSearchLibrary::MotionMatch(class UAnimInstance* AnimInstance, const class UPoseSearchDatabase* Database, const struct FPoseSearchQueryTrajectory& Trajectory, float TrajectorySpeedMultiplier, const class FName PoseHistoryName, struct FPoseSearchBlueprintResult* Result, const class UAnimationAsset* FutureAnimation, float FutureAnimationStartTime, float TimeToFutureAnimationStart, const int32 DebugSessionUniqueIdentifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PoseSearchLibrary", "MotionMatch");

	Params::PoseSearchLibrary_MotionMatch Parms{};

	Parms.AnimInstance = AnimInstance;
	Parms.Database = Database;
	Parms.Trajectory = std::move(Trajectory);
	Parms.TrajectorySpeedMultiplier = TrajectorySpeedMultiplier;
	Parms.PoseHistoryName = PoseHistoryName;
	Parms.FutureAnimation = FutureAnimation;
	Parms.FutureAnimationStartTime = FutureAnimationStartTime;
	Parms.TimeToFutureAnimationStart = TimeToFutureAnimationStart;
	Parms.DebugSessionUniqueIdentifier = DebugSessionUniqueIdentifier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = std::move(Parms.Result);
}

}

