#pragma once

/*
* SDK generated by Dumper-8
*
* https://github.com/NotTacs/Dumper-8
*/

// Package: UnstableLiquidGunRuntime

#include "Basic.hpp"

#include "UnstableLiquidGunRuntime_classes.hpp"
#include "UnstableLiquidGunRuntime_parameters.hpp"


namespace SDK
{

// Function UnstableLiquidGunRuntime.FortLiquidGunProjectile.HandleSplineHit
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void AFortLiquidGunProjectile::HandleSplineHit(const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FortLiquidGunProjectile", "HandleSplineHit");

	Params::FortLiquidGunProjectile_HandleSplineHit Parms{};

	Parms.Hit = std::move(Hit);

	UObject::ProcessEvent(Func, &Parms);
}


// Function UnstableLiquidGunRuntime.FortLiquidGunProjectile.SetDetachmentReason
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELiquidRibbonDetachmentReason           InDetachmentReason                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AFortLiquidGunProjectile::SetDetachmentReason(ELiquidRibbonDetachmentReason InDetachmentReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FortLiquidGunProjectile", "SetDetachmentReason");

	Params::FortLiquidGunProjectile_SetDetachmentReason Parms{};

	Parms.InDetachmentReason = InDetachmentReason;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function UnstableLiquidGunRuntime.FortLiquidGunProjectile.GetDetachmentReason
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELiquidRibbonDetachmentReason           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELiquidRibbonDetachmentReason AFortLiquidGunProjectile::GetDetachmentReason() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FortLiquidGunProjectile", "GetDetachmentReason");

	Params::FortLiquidGunProjectile_GetDetachmentReason Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function UnstableLiquidGunRuntime.LiquidRibbonManager.CalculateSegments
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<struct FVector>&           Points                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const float                             Tension                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FLiquidRibbonSplineSegment>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FLiquidRibbonSplineSegment> ALiquidRibbonManager::CalculateSegments(const TArray<struct FVector>& Points, const float Tension)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LiquidRibbonManager", "CalculateSegments");

	Params::LiquidRibbonManager_CalculateSegments Parms{};

	Parms.Points = std::move(Points);
	Parms.Tension = Tension;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function UnstableLiquidGunRuntime.LiquidRibbonManager.CalculateSplinePointsAndSetNiagaraData
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<class AFortLiquidGunProjectile*>&Projectiles                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    bAttachSplineToMuzzle                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNiagaraComponent*                NiagaraComponent                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>*                 OutAllPositions                                        (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<int32>*                          OutRibbonIDs                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<bool>*                           OutRibbonVisibilities                                  (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<float>*                          OutFlashIntensities                                    (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<int32>*                          OutRibbonSizes                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void ALiquidRibbonManager::CalculateSplinePointsAndSetNiagaraData(const TArray<class AFortLiquidGunProjectile*>& Projectiles, bool bAttachSplineToMuzzle, class UNiagaraComponent* NiagaraComponent, TArray<struct FVector>* OutAllPositions, TArray<int32>* OutRibbonIDs, TArray<bool>* OutRibbonVisibilities, TArray<float>* OutFlashIntensities, TArray<int32>* OutRibbonSizes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LiquidRibbonManager", "CalculateSplinePointsAndSetNiagaraData");

	Params::LiquidRibbonManager_CalculateSplinePointsAndSetNiagaraData Parms{};

	Parms.Projectiles = std::move(Projectiles);
	Parms.bAttachSplineToMuzzle = bAttachSplineToMuzzle;
	Parms.NiagaraComponent = NiagaraComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutAllPositions != nullptr)
		*OutAllPositions = std::move(Parms.OutAllPositions);

	if (OutRibbonIDs != nullptr)
		*OutRibbonIDs = std::move(Parms.OutRibbonIDs);

	if (OutRibbonVisibilities != nullptr)
		*OutRibbonVisibilities = std::move(Parms.OutRibbonVisibilities);

	if (OutFlashIntensities != nullptr)
		*OutFlashIntensities = std::move(Parms.OutFlashIntensities);

	if (OutRibbonSizes != nullptr)
		*OutRibbonSizes = std::move(Parms.OutRibbonSizes);
}


// Function UnstableLiquidGunRuntime.LiquidRibbonManager.GetOrAddDetachment
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const int32                             RibbonID                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLiquidRibbonSplineSegment&Segment                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FLiquidRibbonSplineDetachmentReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FLiquidRibbonSplineDetachment ALiquidRibbonManager::GetOrAddDetachment(const int32 RibbonID, const struct FLiquidRibbonSplineSegment& Segment)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LiquidRibbonManager", "GetOrAddDetachment");

	Params::LiquidRibbonManager_GetOrAddDetachment Parms{};

	Parms.RibbonID = RibbonID;
	Parms.Segment = std::move(Segment);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function UnstableLiquidGunRuntime.LiquidRibbonManager.RunSplineCollisionTestOnProjectiles
// (Final, Native, Public, BlueprintCallable)

void ALiquidRibbonManager::RunSplineCollisionTestOnProjectiles()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LiquidRibbonManager", "RunSplineCollisionTestOnProjectiles");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function UnstableLiquidGunRuntime.LiquidRibbonManager.CalculatePointFlashIntensity
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const int32                             PointSize                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ALiquidRibbonManager::CalculatePointFlashIntensity(const int32 PointSize) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LiquidRibbonManager", "CalculatePointFlashIntensity");

	Params::LiquidRibbonManager_CalculatePointFlashIntensity Parms{};

	Parms.PointSize = PointSize;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function UnstableLiquidGunRuntime.LiquidRibbonManager.CalculatePointSize
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   SegmentIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PointIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ALiquidRibbonManager::CalculatePointSize(int32 SegmentIndex, int32 PointIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LiquidRibbonManager", "CalculatePointSize");

	Params::LiquidRibbonManager_CalculatePointSize Parms{};

	Parms.SegmentIndex = SegmentIndex;
	Parms.PointIndex = PointIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function UnstableLiquidGunRuntime.LiquidRibbonManager.GetFirstVisiblePointIndex
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ALiquidRibbonManager::GetFirstVisiblePointIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LiquidRibbonManager", "GetFirstVisiblePointIndex");

	Params::LiquidRibbonManager_GetFirstVisiblePointIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function UnstableLiquidGunRuntime.LiquidRibbonManager.GetPointOnSegment
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   T                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLiquidRibbonSplineSegment&Segment                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ALiquidRibbonManager::GetPointOnSegment(float T, const struct FLiquidRibbonSplineSegment& Segment) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LiquidRibbonManager", "GetPointOnSegment");

	Params::LiquidRibbonManager_GetPointOnSegment Parms{};

	Parms.T = T;
	Parms.Segment = std::move(Segment);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function UnstableLiquidGunRuntime.LiquidRibbonManager.SetNiagaraData
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UNiagaraComponent*                NiagaraComponent                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FVector>&           Positions                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<int32>&                    RibbonIDs                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<bool>&                     RibbonVisibilities                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<float>&                    FlashIntensities                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<int32>&                    RibbonSizes                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ALiquidRibbonManager::SetNiagaraData(class UNiagaraComponent* NiagaraComponent, const TArray<struct FVector>& Positions, const TArray<int32>& RibbonIDs, const TArray<bool>& RibbonVisibilities, const TArray<float>& FlashIntensities, const TArray<int32>& RibbonSizes) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LiquidRibbonManager", "SetNiagaraData");

	Params::LiquidRibbonManager_SetNiagaraData Parms{};

	Parms.NiagaraComponent = NiagaraComponent;
	Parms.Positions = std::move(Positions);
	Parms.RibbonIDs = std::move(RibbonIDs);
	Parms.RibbonVisibilities = std::move(RibbonVisibilities);
	Parms.FlashIntensities = std::move(FlashIntensities);
	Parms.RibbonSizes = std::move(RibbonSizes);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}

}

