#pragma once

/*
* SDK generated by Dumper-8
*
* https://github.com/NotTacs/Dumper-8
*/

// Package: Mover

#include "Basic.hpp"

#include "Mover_classes.hpp"
#include "Mover_parameters.hpp"


namespace SDK
{

// Function Mover.TurnGeneratorInterface.GetTurn
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// const struct FRotator&                  TargetOrientation                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// const struct FKinematicMoverTickStartData&FullStartState                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FMoverDefaultSyncState&    MoverState                                             (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// const struct FMoverTimeStep&            TimeStep                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FProposedMove&             ProposedMove                                           (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// class UMoverBlackboard*                 SimBlackboard                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator ITurnGeneratorInterface::GetTurn(const struct FRotator& TargetOrientation, const struct FKinematicMoverTickStartData& FullStartState, const struct FMoverDefaultSyncState& MoverState, const struct FMoverTimeStep& TimeStep, const struct FProposedMove& ProposedMove, class UMoverBlackboard* SimBlackboard)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = AsUObject()->Class->GetFunction("TurnGeneratorInterface", "GetTurn");

	Params::TurnGeneratorInterface_GetTurn Parms{};

	Parms.TargetOrientation = std::move(TargetOrientation);
	Parms.FullStartState = std::move(FullStartState);
	Parms.MoverState = std::move(MoverState);
	Parms.TimeStep = std::move(TimeStep);
	Parms.ProposedMove = std::move(ProposedMove);
	Parms.SimBlackboard = SimBlackboard;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	AsUObject()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.MoverBasePawn.OnProduceInputInBlueprint
// (Event, Protected, BlueprintEvent)
// Parameters:
// float                                   DeltaMs                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FKinematicMoverInputCmdContext&InputCmd                                               (Parm, NativeAccessSpecifierPublic)
// struct FKinematicMoverInputCmdContext   ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FKinematicMoverInputCmdContext AMoverBasePawn::OnProduceInputInBlueprint(float DeltaMs, const struct FKinematicMoverInputCmdContext& InputCmd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoverBasePawn", "OnProduceInputInBlueprint");

	Params::MoverBasePawn_OnProduceInputInBlueprint Parms{};

	Parms.DeltaMs = DeltaMs;
	Parms.InputCmd = std::move(InputCmd);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Mover.MoverBasePawn.GetMoverComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UKinematicMoverComponent*         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UKinematicMoverComponent* AMoverBasePawn::GetMoverComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoverBasePawn", "GetMoverComponent");

	Params::MoverBasePawn_GetMoverComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.MoverDataModelBlueprintLibrary.GetLocationFromSyncState
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FMoverDefaultSyncState&    SyncState                                              (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMoverDataModelBlueprintLibrary::GetLocationFromSyncState(const struct FMoverDefaultSyncState& SyncState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MoverDataModelBlueprintLibrary", "GetLocationFromSyncState");

	Params::MoverDataModelBlueprintLibrary_GetLocationFromSyncState Parms{};

	Parms.SyncState = std::move(SyncState);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.MoverDataModelBlueprintLibrary.GetMoveDirectionIntentFromInputs
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FKinematicDefaultInputs&   Inputs                                                 (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMoverDataModelBlueprintLibrary::GetMoveDirectionIntentFromInputs(const struct FKinematicDefaultInputs& Inputs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MoverDataModelBlueprintLibrary", "GetMoveDirectionIntentFromInputs");

	Params::MoverDataModelBlueprintLibrary_GetMoveDirectionIntentFromInputs Parms{};

	Parms.Inputs = std::move(Inputs);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.MoverDataModelBlueprintLibrary.GetMoveDirectionIntentFromSyncState
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FMoverDefaultSyncState&    SyncState                                              (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMoverDataModelBlueprintLibrary::GetMoveDirectionIntentFromSyncState(const struct FMoverDefaultSyncState& SyncState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MoverDataModelBlueprintLibrary", "GetMoveDirectionIntentFromSyncState");

	Params::MoverDataModelBlueprintLibrary_GetMoveDirectionIntentFromSyncState Parms{};

	Parms.SyncState = std::move(SyncState);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.MoverDataModelBlueprintLibrary.GetOrientationFromSyncState
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FMoverDefaultSyncState&    SyncState                                              (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UMoverDataModelBlueprintLibrary::GetOrientationFromSyncState(const struct FMoverDefaultSyncState& SyncState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MoverDataModelBlueprintLibrary", "GetOrientationFromSyncState");

	Params::MoverDataModelBlueprintLibrary_GetOrientationFromSyncState Parms{};

	Parms.SyncState = std::move(SyncState);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.MoverDataModelBlueprintLibrary.GetVelocityFromSyncState
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FMoverDefaultSyncState&    SyncState                                              (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMoverDataModelBlueprintLibrary::GetVelocityFromSyncState(const struct FMoverDefaultSyncState& SyncState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MoverDataModelBlueprintLibrary", "GetVelocityFromSyncState");

	Params::MoverDataModelBlueprintLibrary_GetVelocityFromSyncState Parms{};

	Parms.SyncState = std::move(SyncState);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.MoverDebugComponent.OnHistoryTrackingRollback
// (Final, Native, Protected, HasOutParams)
// Parameters:
// const struct FMoverTimeStep&            NewTimeStep                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FMoverTimeStep&            InvalidatedTimeStep                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UMoverDebugComponent::OnHistoryTrackingRollback(const struct FMoverTimeStep& NewTimeStep, const struct FMoverTimeStep& InvalidatedTimeStep)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoverDebugComponent", "OnHistoryTrackingRollback");

	Params::MoverDebugComponent_OnHistoryTrackingRollback Parms{};

	Parms.NewTimeStep = std::move(NewTimeStep);
	Parms.InvalidatedTimeStep = std::move(InvalidatedTimeStep);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mover.MoverDebugComponent.OnMovementSimRollback
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FMoverTimeStep&            NewTimeStep                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FMoverTimeStep&            InvalidatedTimeStep                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UMoverDebugComponent::OnMovementSimRollback(const struct FMoverTimeStep& NewTimeStep, const struct FMoverTimeStep& InvalidatedTimeStep)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoverDebugComponent", "OnMovementSimRollback");

	Params::MoverDebugComponent_OnMovementSimRollback Parms{};

	Parms.NewTimeStep = std::move(NewTimeStep);
	Parms.InvalidatedTimeStep = std::move(InvalidatedTimeStep);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mover.MoverDebugComponent.OnMovementSimTick
// (Final, Native, Private, HasOutParams)
// Parameters:
// const struct FMoverTimeStep&            TimeStep                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UMoverDebugComponent::OnMovementSimTick(const struct FMoverTimeStep& TimeStep)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoverDebugComponent", "OnMovementSimTick");

	Params::MoverDebugComponent_OnMovementSimTick Parms{};

	Parms.TimeStep = std::move(TimeStep);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mover.MoverDebugComponent.SetHistoryTracking
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   SecondsToTrack                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SamplesPerSecond                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMoverDebugComponent::SetHistoryTracking(float SecondsToTrack, float SamplesPerSecond)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoverDebugComponent", "SetHistoryTracking");

	Params::MoverDebugComponent_SetHistoryTracking Parms{};

	Parms.SecondsToTrack = SecondsToTrack;
	Parms.SamplesPerSecond = SamplesPerSecond;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mover.MoverDebugComponent.GetFutureTrajectory
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// float                                   FutureSeconds                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   SamplesPerSecond                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FTrajectorySampleInfo>    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FTrajectorySampleInfo> UMoverDebugComponent::GetFutureTrajectory(float FutureSeconds, float SamplesPerSecond) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoverDebugComponent", "GetFutureTrajectory");

	Params::MoverDebugComponent_GetFutureTrajectory Parms{};

	Parms.FutureSeconds = FutureSeconds;
	Parms.SamplesPerSecond = SamplesPerSecond;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.MoverDebugComponent.GetPastTrajectory
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// TArray<struct FTrajectorySampleInfo>    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FTrajectorySampleInfo> UMoverDebugComponent::GetPastTrajectory() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MoverDebugComponent", "GetPastTrajectory");

	Params::MoverDebugComponent_GetPastTrajectory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.MoverDataCollectionLibrary.K2_AddDataToCollection
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FMoverDataCollection&            Collection                                             (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const int32&                            SourceAsRawBytes                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMoverDataCollectionLibrary::K2_AddDataToCollection(struct FMoverDataCollection& Collection, const int32& SourceAsRawBytes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MoverDataCollectionLibrary", "K2_AddDataToCollection");

	Params::MoverDataCollectionLibrary_K2_AddDataToCollection Parms{};

	Parms.Collection = std::move(Collection);
	Parms.SourceAsRawBytes = SourceAsRawBytes;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Collection = std::move(Parms.Collection);
}


// Function Mover.MoverDataCollectionLibrary.K2_GetDataFromCollection
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// bool*                                   DidSucceed                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMoverDataCollection&      Collection                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32*                                  TargetAsRawBytes                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMoverDataCollectionLibrary::K2_GetDataFromCollection(bool* DidSucceed, const struct FMoverDataCollection& Collection, int32* TargetAsRawBytes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MoverDataCollectionLibrary", "K2_GetDataFromCollection");

	Params::MoverDataCollectionLibrary_K2_GetDataFromCollection Parms{};

	Parms.Collection = std::move(Collection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (DidSucceed != nullptr)
		*DidSucceed = Parms.DidSucceed;

	if (TargetAsRawBytes != nullptr)
		*TargetAsRawBytes = Parms.TargetAsRawBytes;
}


// Function Mover.KinematicMoverComponent.HandleImpact
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FMoverOnImpactParams*            ImpactParams                                           (Parm, OutParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UKinematicMoverComponent::HandleImpact(struct FMoverOnImpactParams* ImpactParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KinematicMoverComponent", "HandleImpact");

	Params::KinematicMoverComponent_HandleImpact Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ImpactParams != nullptr)
		*ImpactParams = std::move(Parms.ImpactParams);
}


// Function Mover.KinematicMoverComponent.K2_QueueLayeredMove
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const int32&                            MoveAsRawData                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKinematicMoverComponent::K2_QueueLayeredMove(const int32& MoveAsRawData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KinematicMoverComponent", "K2_QueueLayeredMove");

	Params::KinematicMoverComponent_K2_QueueLayeredMove Parms{};

	Parms.MoveAsRawData = MoveAsRawData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mover.KinematicMoverComponent.OnBeginOverlap
// (Native, Public, HasOutParams)
// Parameters:
// class UPrimitiveComponent*              OverlappedComp                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Other                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              OtherComp                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OtherBodyIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFromSweep                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                SweepResult                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UKinematicMoverComponent::OnBeginOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* Other, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KinematicMoverComponent", "OnBeginOverlap");

	Params::KinematicMoverComponent_OnBeginOverlap Parms{};

	Parms.OverlappedComp = OverlappedComp;
	Parms.Other = Other;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mover.KinematicMoverComponent.PhysicsVolumeChanged
// (Native, Protected)
// Parameters:
// class APhysicsVolume*                   NewVolume                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKinematicMoverComponent::PhysicsVolumeChanged(class APhysicsVolume* NewVolume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KinematicMoverComponent", "PhysicsVolumeChanged");

	Params::KinematicMoverComponent_PhysicsVolumeChanged Parms{};

	Parms.NewVolume = NewVolume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mover.KinematicMoverComponent.QueueNextMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             DesiredModeName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldReenter                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKinematicMoverComponent::QueueNextMode(class FName DesiredModeName, bool bShouldReenter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KinematicMoverComponent", "QueueNextMode");

	Params::KinematicMoverComponent_QueueNextMode Parms{};

	Parms.DesiredModeName = DesiredModeName;
	Parms.bShouldReenter = bShouldReenter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mover.KinematicMoverComponent.SetGravityOverride
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// bool                                    bOverrideGravity                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   GravityAcceleration                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UKinematicMoverComponent::SetGravityOverride(bool bOverrideGravity, const struct FVector& GravityAcceleration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KinematicMoverComponent", "SetGravityOverride");

	Params::KinematicMoverComponent_SetGravityOverride Parms{};

	Parms.bOverrideGravity = bOverrideGravity;
	Parms.GravityAcceleration = std::move(GravityAcceleration);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function Mover.KinematicMoverComponent.FindMovementMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UBaseMovementMode>    MovementMode                                           (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UBaseMovementMode*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UBaseMovementMode* UKinematicMoverComponent::FindMovementMode(TSubclassOf<class UBaseMovementMode> MovementMode) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KinematicMoverComponent", "FindMovementMode");

	Params::KinematicMoverComponent_FindMovementMode Parms{};

	Parms.MovementMode = MovementMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.KinematicMoverComponent.GetGravityAcceleration
// (Final, Native, Public, HasDefaults, BlueprintCallable, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKinematicMoverComponent::GetGravityAcceleration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KinematicMoverComponent", "GetGravityAcceleration");

	Params::KinematicMoverComponent_GetGravityAcceleration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.KinematicMoverComponent.GetLastInputCmd
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FKinematicMoverInputCmdContextReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FKinematicMoverInputCmdContext UKinematicMoverComponent::GetLastInputCmd() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KinematicMoverComponent", "GetLastInputCmd");

	Params::KinematicMoverComponent_GetLastInputCmd Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.KinematicMoverComponent.GetMovementBase
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UPrimitiveComponent*              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPrimitiveComponent* UKinematicMoverComponent::GetMovementBase() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KinematicMoverComponent", "GetMovementBase");

	Params::KinematicMoverComponent_GetMovementBase Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.KinematicMoverComponent.GetMovementBaseBoneName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UKinematicMoverComponent::GetMovementBaseBoneName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KinematicMoverComponent", "GetMovementBaseBoneName");

	Params::KinematicMoverComponent_GetMovementBaseBoneName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.KinematicMoverComponent.GetMovementIntent
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKinematicMoverComponent::GetMovementIntent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KinematicMoverComponent", "GetMovementIntent");

	Params::KinematicMoverComponent_GetMovementIntent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.KinematicMoverComponent.GetMovementModeName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UKinematicMoverComponent::GetMovementModeName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KinematicMoverComponent", "GetMovementModeName");

	Params::KinematicMoverComponent_GetMovementModeName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.KinematicMoverComponent.GetSyncState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FKinematicMoverSyncState   ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FKinematicMoverSyncState UKinematicMoverComponent::GetSyncState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KinematicMoverComponent", "GetSyncState");

	Params::KinematicMoverComponent_GetSyncState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.KinematicMoverComponent.GetTargetOrientation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UKinematicMoverComponent::GetTargetOrientation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KinematicMoverComponent", "GetTargetOrientation");

	Params::KinematicMoverComponent_GetTargetOrientation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.KinematicMoverComponent.GetUpDirection
// (Final, Native, Public, HasDefaults, BlueprintCallable, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKinematicMoverComponent::GetUpDirection() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KinematicMoverComponent", "GetUpDirection");

	Params::KinematicMoverComponent_GetUpDirection Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.KinematicMoverComponent.GetVelocity
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UKinematicMoverComponent::GetVelocity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KinematicMoverComponent", "GetVelocity");

	Params::KinematicMoverComponent_GetVelocity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.KinematicMoverComponent.HasValidCachedInputCmd
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKinematicMoverComponent::HasValidCachedInputCmd() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KinematicMoverComponent", "HasValidCachedInputCmd");

	Params::KinematicMoverComponent_HasValidCachedInputCmd Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.KinematicMoverComponent.HasValidCachedState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKinematicMoverComponent::HasValidCachedState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KinematicMoverComponent", "HasValidCachedState");

	Params::KinematicMoverComponent_HasValidCachedState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.KinematicMoverComponent.IsAirborne
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKinematicMoverComponent::IsAirborne() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KinematicMoverComponent", "IsAirborne");

	Params::KinematicMoverComponent_IsAirborne Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.KinematicMoverComponent.IsFalling
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKinematicMoverComponent::IsFalling() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KinematicMoverComponent", "IsFalling");

	Params::KinematicMoverComponent_IsFalling Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.KinematicMoverComponent.IsOnGround
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKinematicMoverComponent::IsOnGround() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KinematicMoverComponent", "IsOnGround");

	Params::KinematicMoverComponent_IsOnGround Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.KinematicMoverComponent.TryGetFloorCheckHitResult
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FHitResult*                      OutHitResult                                           (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UKinematicMoverComponent::TryGetFloorCheckHitResult(struct FHitResult* OutHitResult) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("KinematicMoverComponent", "TryGetFloorCheckHitResult");

	Params::KinematicMoverComponent_TryGetFloorCheckHitResult Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHitResult != nullptr)
		*OutHitResult = std::move(Parms.OutHitResult);

	return Parms.ReturnValue;
}


// Function Mover.BaseMovementMode.K2_OnRegistered
// (Event, Protected, BlueprintEvent)
// Parameters:
// const class FName                       ModeName                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBaseMovementMode::K2_OnRegistered(const class FName ModeName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseMovementMode", "K2_OnRegistered");

	Params::BaseMovementMode_K2_OnRegistered Parms{};

	Parms.ModeName = ModeName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function Mover.BaseMovementMode.K2_OnSimulationTick
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// const struct FSimulationTickParams&     Params_0                                               (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FKinematicMoverTickEndData       ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FKinematicMoverTickEndData UBaseMovementMode::K2_OnSimulationTick(const struct FSimulationTickParams& Params_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseMovementMode", "K2_OnSimulationTick");

	Params::BaseMovementMode_K2_OnSimulationTick Parms{};

	Parms.Params_0 = std::move(Params_0);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Mover.BaseMovementMode.K2_OnUnregistered
// (Event, Protected, BlueprintEvent)

void UBaseMovementMode::K2_OnUnregistered()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseMovementMode", "K2_OnUnregistered");

	UObject::ProcessEvent(Func, nullptr);
}


// Function Mover.BaseMovementMode.GetBlackboard
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UMoverBlackboard*           ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UMoverBlackboard* UBaseMovementMode::GetBlackboard() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseMovementMode", "GetBlackboard");

	Params::BaseMovementMode_GetBlackboard Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.BaseMovementMode.GetBlackboard_Mutable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UMoverBlackboard*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMoverBlackboard* UBaseMovementMode::GetBlackboard_Mutable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseMovementMode", "GetBlackboard_Mutable");

	Params::BaseMovementMode_GetBlackboard_Mutable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.BaseMovementMode.GetMoverComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UKinematicMoverComponent*         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UKinematicMoverComponent* UBaseMovementMode::GetMoverComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseMovementMode", "GetMoverComponent");

	Params::BaseMovementMode_GetMoverComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.BaseMovementMode.K2_OnGenerateMove
// (Event, Protected, HasOutParams, BlueprintEvent, Const)
// Parameters:
// const struct FKinematicMoverTickStartData&StartState                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FMoverTimeStep&            TimeStep                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FProposedMove                    ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FProposedMove UBaseMovementMode::K2_OnGenerateMove(const struct FKinematicMoverTickStartData& StartState, const struct FMoverTimeStep& TimeStep) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BaseMovementMode", "K2_OnGenerateMove");

	Params::BaseMovementMode_K2_OnGenerateMove Parms{};

	Parms.StartState = std::move(StartState);
	Parms.TimeStep = std::move(TimeStep);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function Mover.FallingMode.OnSimulationTick
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FSimulationTickParams&     Params_0                                               (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FKinematicMoverTickEndData*      OutputState                                            (Parm, OutParm, NativeAccessSpecifierPublic)

void UFallingMode::OnSimulationTick(const struct FSimulationTickParams& Params_0, struct FKinematicMoverTickEndData* OutputState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FallingMode", "OnSimulationTick");

	Params::FallingMode_OnSimulationTick Parms{};

	Parms.Params_0 = std::move(Params_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutputState != nullptr)
		*OutputState = std::move(Parms.OutputState);
}


// Function Mover.FallingMode.OnGenerateMove
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FKinematicMoverTickStartData&StartState                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FMoverTimeStep&            TimeStep                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FProposedMove*                   OutProposedMove                                        (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UFallingMode::OnGenerateMove(const struct FKinematicMoverTickStartData& StartState, const struct FMoverTimeStep& TimeStep, struct FProposedMove* OutProposedMove) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FallingMode", "OnGenerateMove");

	Params::FallingMode_OnGenerateMove Parms{};

	Parms.StartState = std::move(StartState);
	Parms.TimeStep = std::move(TimeStep);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutProposedMove != nullptr)
		*OutProposedMove = std::move(Parms.OutProposedMove);
}


// Function Mover.FallingMode.ProcessLanded
// (Native, Protected, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FFloorCheckResult&         FloorResult                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector*                         Velocity                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRelativeBaseInfo*               BaseInfo                                               (Parm, OutParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FKinematicMoverTickEndData*      TickEndData                                            (Parm, OutParm, NativeAccessSpecifierPublic)

void UFallingMode::ProcessLanded(const struct FFloorCheckResult& FloorResult, struct FVector* Velocity, struct FRelativeBaseInfo* BaseInfo, struct FKinematicMoverTickEndData* TickEndData) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FallingMode", "ProcessLanded");

	Params::FallingMode_ProcessLanded Parms{};

	Parms.FloorResult = std::move(FloorResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Velocity != nullptr)
		*Velocity = std::move(Parms.Velocity);

	if (BaseInfo != nullptr)
		*BaseInfo = std::move(Parms.BaseInfo);

	if (TickEndData != nullptr)
		*TickEndData = std::move(Parms.TickEndData);
}


// Function Mover.FlyingMode.OnSimulationTick
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FSimulationTickParams&     Params_0                                               (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FKinematicMoverTickEndData*      OutputState                                            (Parm, OutParm, NativeAccessSpecifierPublic)

void UFlyingMode::OnSimulationTick(const struct FSimulationTickParams& Params_0, struct FKinematicMoverTickEndData* OutputState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlyingMode", "OnSimulationTick");

	Params::FlyingMode_OnSimulationTick Parms{};

	Parms.Params_0 = std::move(Params_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutputState != nullptr)
		*OutputState = std::move(Parms.OutputState);
}


// Function Mover.FlyingMode.OnGenerateMove
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FKinematicMoverTickStartData&StartState                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FMoverTimeStep&            TimeStep                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FProposedMove*                   OutProposedMove                                        (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UFlyingMode::OnGenerateMove(const struct FKinematicMoverTickStartData& StartState, const struct FMoverTimeStep& TimeStep, struct FProposedMove* OutProposedMove) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FlyingMode", "OnGenerateMove");

	Params::FlyingMode_OnGenerateMove Parms{};

	Parms.StartState = std::move(StartState);
	Parms.TimeStep = std::move(TimeStep);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutProposedMove != nullptr)
		*OutProposedMove = std::move(Parms.OutProposedMove);
}


// Function Mover.SwimmingMode.OnSimulationTick
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FSimulationTickParams&     Params_0                                               (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FKinematicMoverTickEndData*      OutputState                                            (Parm, OutParm, NativeAccessSpecifierPublic)

void USwimmingMode::OnSimulationTick(const struct FSimulationTickParams& Params_0, struct FKinematicMoverTickEndData* OutputState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SwimmingMode", "OnSimulationTick");

	Params::SwimmingMode_OnSimulationTick Parms{};

	Parms.Params_0 = std::move(Params_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutputState != nullptr)
		*OutputState = std::move(Parms.OutputState);
}


// Function Mover.SwimmingMode.OnGenerateMove
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FKinematicMoverTickStartData&StartState                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FMoverTimeStep&            TimeStep                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FProposedMove*                   OutProposedMove                                        (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void USwimmingMode::OnGenerateMove(const struct FKinematicMoverTickStartData& StartState, const struct FMoverTimeStep& TimeStep, struct FProposedMove* OutProposedMove) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SwimmingMode", "OnGenerateMove");

	Params::SwimmingMode_OnGenerateMove Parms{};

	Parms.StartState = std::move(StartState);
	Parms.TimeStep = std::move(TimeStep);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutProposedMove != nullptr)
		*OutProposedMove = std::move(Parms.OutProposedMove);
}


// Function Mover.WalkingMode.OnSimulationTick
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FSimulationTickParams&     Params_0                                               (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FKinematicMoverTickEndData*      OutputState                                            (Parm, OutParm, NativeAccessSpecifierPublic)

void UWalkingMode::OnSimulationTick(const struct FSimulationTickParams& Params_0, struct FKinematicMoverTickEndData* OutputState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WalkingMode", "OnSimulationTick");

	Params::WalkingMode_OnSimulationTick Parms{};

	Parms.Params_0 = std::move(Params_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutputState != nullptr)
		*OutputState = std::move(Parms.OutputState);
}


// Function Mover.WalkingMode.OnGenerateMove
// (Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FKinematicMoverTickStartData&StartState                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FMoverTimeStep&            TimeStep                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FProposedMove*                   OutProposedMove                                        (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UWalkingMode::OnGenerateMove(const struct FKinematicMoverTickStartData& StartState, const struct FMoverTimeStep& TimeStep, struct FProposedMove* OutProposedMove) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WalkingMode", "OnGenerateMove");

	Params::WalkingMode_OnGenerateMove Parms{};

	Parms.StartState = std::move(StartState);
	Parms.TimeStep = std::move(TimeStep);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutProposedMove != nullptr)
		*OutProposedMove = std::move(Parms.OutProposedMove);
}


// Function Mover.MovementBaseUtils.GetMovementBaseTransform
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class UPrimitiveComponent*        MovementBase                                           (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       BoneName                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         OutLocation                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FQuat*                           OutQuat                                                (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMovementBaseUtils::GetMovementBaseTransform(const class UPrimitiveComponent* MovementBase, const class FName BoneName, struct FVector* OutLocation, struct FQuat* OutQuat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MovementBaseUtils", "GetMovementBaseTransform");

	Params::MovementBaseUtils_GetMovementBaseTransform Parms{};

	Parms.MovementBase = MovementBase;
	Parms.BoneName = BoneName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLocation != nullptr)
		*OutLocation = std::move(Parms.OutLocation);

	if (OutQuat != nullptr)
		*OutQuat = std::move(Parms.OutQuat);

	return Parms.ReturnValue;
}


// Function Mover.MovementBaseUtils.IsADynamicBase
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UPrimitiveComponent*        MovementBase                                           (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMovementBaseUtils::IsADynamicBase(const class UPrimitiveComponent* MovementBase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MovementBaseUtils", "IsADynamicBase");

	Params::MovementBaseUtils_IsADynamicBase Parms{};

	Parms.MovementBase = MovementBase;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.MovementBaseUtils.TransformBasedDirectionToWorld
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class UPrimitiveComponent*        MovementBase                                           (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       BoneName                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   LocalDirection                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         OutDirectionWorldSpace                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMovementBaseUtils::TransformBasedDirectionToWorld(const class UPrimitiveComponent* MovementBase, const class FName BoneName, const struct FVector& LocalDirection, struct FVector* OutDirectionWorldSpace)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MovementBaseUtils", "TransformBasedDirectionToWorld");

	Params::MovementBaseUtils_TransformBasedDirectionToWorld Parms{};

	Parms.MovementBase = MovementBase;
	Parms.BoneName = BoneName;
	Parms.LocalDirection = std::move(LocalDirection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutDirectionWorldSpace != nullptr)
		*OutDirectionWorldSpace = std::move(Parms.OutDirectionWorldSpace);

	return Parms.ReturnValue;
}


// Function Mover.MovementBaseUtils.TransformBasedLocationToWorld
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class UPrimitiveComponent*        MovementBase                                           (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       BoneName                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   LocalLocation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         OutLocationWorldSpace                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMovementBaseUtils::TransformBasedLocationToWorld(const class UPrimitiveComponent* MovementBase, const class FName BoneName, const struct FVector& LocalLocation, struct FVector* OutLocationWorldSpace)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MovementBaseUtils", "TransformBasedLocationToWorld");

	Params::MovementBaseUtils_TransformBasedLocationToWorld Parms{};

	Parms.MovementBase = MovementBase;
	Parms.BoneName = BoneName;
	Parms.LocalLocation = std::move(LocalLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLocationWorldSpace != nullptr)
		*OutLocationWorldSpace = std::move(Parms.OutLocationWorldSpace);

	return Parms.ReturnValue;
}


// Function Mover.MovementBaseUtils.TransformBasedRotatorToWorld
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class UPrimitiveComponent*        MovementBase                                           (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       BoneName                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  LocalRotator                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator*                        OutWorldSpaceRotator                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMovementBaseUtils::TransformBasedRotatorToWorld(const class UPrimitiveComponent* MovementBase, const class FName BoneName, const struct FRotator& LocalRotator, struct FRotator* OutWorldSpaceRotator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MovementBaseUtils", "TransformBasedRotatorToWorld");

	Params::MovementBaseUtils_TransformBasedRotatorToWorld Parms{};

	Parms.MovementBase = MovementBase;
	Parms.BoneName = BoneName;
	Parms.LocalRotator = std::move(LocalRotator);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutWorldSpaceRotator != nullptr)
		*OutWorldSpaceRotator = std::move(Parms.OutWorldSpaceRotator);

	return Parms.ReturnValue;
}


// Function Mover.MovementBaseUtils.TransformDirectionToLocal
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FQuat&                     BaseQuat                                               (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   WorldSpaceDirection                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         OutLocalDirection                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMovementBaseUtils::TransformDirectionToLocal(const struct FQuat& BaseQuat, const struct FVector& WorldSpaceDirection, struct FVector* OutLocalDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MovementBaseUtils", "TransformDirectionToLocal");

	Params::MovementBaseUtils_TransformDirectionToLocal Parms{};

	Parms.BaseQuat = std::move(BaseQuat);
	Parms.WorldSpaceDirection = std::move(WorldSpaceDirection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLocalDirection != nullptr)
		*OutLocalDirection = std::move(Parms.OutLocalDirection);
}


// Function Mover.MovementBaseUtils.TransformDirectionToWorld
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FQuat&                     BaseQuat                                               (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   LocalDirection                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         OutDirectionWorldSpace                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMovementBaseUtils::TransformDirectionToWorld(const struct FQuat& BaseQuat, const struct FVector& LocalDirection, struct FVector* OutDirectionWorldSpace)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MovementBaseUtils", "TransformDirectionToWorld");

	Params::MovementBaseUtils_TransformDirectionToWorld Parms{};

	Parms.BaseQuat = std::move(BaseQuat);
	Parms.LocalDirection = std::move(LocalDirection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutDirectionWorldSpace != nullptr)
		*OutDirectionWorldSpace = std::move(Parms.OutDirectionWorldSpace);
}


// Function Mover.MovementBaseUtils.TransformLocationToLocal
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   BasePos                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FQuat&                     BaseQuat                                               (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   WorldSpaceLocation                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         OutLocalLocation                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMovementBaseUtils::TransformLocationToLocal(const struct FVector& BasePos, const struct FQuat& BaseQuat, const struct FVector& WorldSpaceLocation, struct FVector* OutLocalLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MovementBaseUtils", "TransformLocationToLocal");

	Params::MovementBaseUtils_TransformLocationToLocal Parms{};

	Parms.BasePos = std::move(BasePos);
	Parms.BaseQuat = std::move(BaseQuat);
	Parms.WorldSpaceLocation = std::move(WorldSpaceLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLocalLocation != nullptr)
		*OutLocalLocation = std::move(Parms.OutLocalLocation);
}


// Function Mover.MovementBaseUtils.TransformLocationToWorld
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   BasePos                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FQuat&                     BaseQuat                                               (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   LocalLocation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         OutLocationWorldSpace                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMovementBaseUtils::TransformLocationToWorld(const struct FVector& BasePos, const struct FQuat& BaseQuat, const struct FVector& LocalLocation, struct FVector* OutLocationWorldSpace)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MovementBaseUtils", "TransformLocationToWorld");

	Params::MovementBaseUtils_TransformLocationToWorld Parms{};

	Parms.BasePos = std::move(BasePos);
	Parms.BaseQuat = std::move(BaseQuat);
	Parms.LocalLocation = std::move(LocalLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLocationWorldSpace != nullptr)
		*OutLocationWorldSpace = std::move(Parms.OutLocationWorldSpace);
}


// Function Mover.MovementBaseUtils.TransformRotatorToLocal
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FQuat&                     BaseQuat                                               (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  WorldSpaceRotator                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator*                        OutLocalRotator                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UMovementBaseUtils::TransformRotatorToLocal(const struct FQuat& BaseQuat, const struct FRotator& WorldSpaceRotator, struct FRotator* OutLocalRotator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MovementBaseUtils", "TransformRotatorToLocal");

	Params::MovementBaseUtils_TransformRotatorToLocal Parms{};

	Parms.BaseQuat = std::move(BaseQuat);
	Parms.WorldSpaceRotator = std::move(WorldSpaceRotator);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLocalRotator != nullptr)
		*OutLocalRotator = std::move(Parms.OutLocalRotator);
}


// Function Mover.MovementBaseUtils.TransformRotatorToWorld
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FQuat&                     BaseQuat                                               (Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  LocalRotator                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator*                        OutWorldSpaceRotator                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UMovementBaseUtils::TransformRotatorToWorld(const struct FQuat& BaseQuat, const struct FRotator& LocalRotator, struct FRotator* OutWorldSpaceRotator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MovementBaseUtils", "TransformRotatorToWorld");

	Params::MovementBaseUtils_TransformRotatorToWorld Parms{};

	Parms.BaseQuat = std::move(BaseQuat);
	Parms.LocalRotator = std::move(LocalRotator);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutWorldSpaceRotator != nullptr)
		*OutWorldSpaceRotator = std::move(Parms.OutWorldSpaceRotator);
}


// Function Mover.MovementBaseUtils.TransformWorldDirectionToBased
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class UPrimitiveComponent*        MovementBase                                           (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       BoneName                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   WorldSpaceDirection                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         OutLocalDirection                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMovementBaseUtils::TransformWorldDirectionToBased(const class UPrimitiveComponent* MovementBase, const class FName BoneName, const struct FVector& WorldSpaceDirection, struct FVector* OutLocalDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MovementBaseUtils", "TransformWorldDirectionToBased");

	Params::MovementBaseUtils_TransformWorldDirectionToBased Parms{};

	Parms.MovementBase = MovementBase;
	Parms.BoneName = BoneName;
	Parms.WorldSpaceDirection = std::move(WorldSpaceDirection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLocalDirection != nullptr)
		*OutLocalDirection = std::move(Parms.OutLocalDirection);

	return Parms.ReturnValue;
}


// Function Mover.MovementBaseUtils.TransformWorldLocationToBased
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class UPrimitiveComponent*        MovementBase                                           (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       BoneName                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   WorldSpaceLocation                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         OutLocalLocation                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMovementBaseUtils::TransformWorldLocationToBased(const class UPrimitiveComponent* MovementBase, const class FName BoneName, const struct FVector& WorldSpaceLocation, struct FVector* OutLocalLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MovementBaseUtils", "TransformWorldLocationToBased");

	Params::MovementBaseUtils_TransformWorldLocationToBased Parms{};

	Parms.MovementBase = MovementBase;
	Parms.BoneName = BoneName;
	Parms.WorldSpaceLocation = std::move(WorldSpaceLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLocalLocation != nullptr)
		*OutLocalLocation = std::move(Parms.OutLocalLocation);

	return Parms.ReturnValue;
}


// Function Mover.MovementBaseUtils.TransformWorldRotatorToBased
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class UPrimitiveComponent*        MovementBase                                           (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class FName                       BoneName                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRotator&                  WorldSpaceRotator                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FRotator*                        OutLocalRotator                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMovementBaseUtils::TransformWorldRotatorToBased(const class UPrimitiveComponent* MovementBase, const class FName BoneName, const struct FRotator& WorldSpaceRotator, struct FRotator* OutLocalRotator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MovementBaseUtils", "TransformWorldRotatorToBased");

	Params::MovementBaseUtils_TransformWorldRotatorToBased Parms{};

	Parms.MovementBase = MovementBase;
	Parms.BoneName = BoneName;
	Parms.WorldSpaceRotator = std::move(WorldSpaceRotator);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLocalRotator != nullptr)
		*OutLocalRotator = std::move(Parms.OutLocalRotator);

	return Parms.ReturnValue;
}


// Function Mover.MovementUtils.AdjustProposedMoveForRootMotion
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FProposedMove*                   MoveToAdjust                                           (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           SkeletalMesh                                           (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   GroundNormal                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMovementUtils::AdjustProposedMoveForRootMotion(struct FProposedMove* MoveToAdjust, class USkeletalMeshComponent* SkeletalMesh, const struct FVector& GroundNormal, float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MovementUtils", "AdjustProposedMoveForRootMotion");

	Params::MovementUtils_AdjustProposedMoveForRootMotion Parms{};

	Parms.SkeletalMesh = SkeletalMesh;
	Parms.GroundNormal = std::move(GroundNormal);
	Parms.DeltaSeconds = DeltaSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (MoveToAdjust != nullptr)
		*MoveToAdjust = std::move(Parms.MoveToAdjust);
}


// Function Mover.MovementUtils.CanEscapeGravity
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   PriorVelocity                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   NewVelocity                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   GravityAccel                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMovementUtils::CanEscapeGravity(const struct FVector& PriorVelocity, const struct FVector& NewVelocity, const struct FVector& GravityAccel, float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MovementUtils", "CanEscapeGravity");

	Params::MovementUtils_CanEscapeGravity Parms{};

	Parms.PriorVelocity = std::move(PriorVelocity);
	Parms.NewVelocity = std::move(NewVelocity);
	Parms.GravityAccel = std::move(GravityAccel);
	Parms.DeltaSeconds = DeltaSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.MovementUtils.CanStepUpOnHitSurface
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMovementUtils::CanStepUpOnHitSurface(const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MovementUtils", "CanStepUpOnHitSurface");

	Params::MovementUtils_CanStepUpOnHitSurface Parms{};

	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.MovementUtils.ComputeAngularVelocity
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FRotator&                  From                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// const struct FRotator&                  To                                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TurningRateLimit                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FRotator UMovementUtils::ComputeAngularVelocity(const struct FRotator& From, const struct FRotator& To, float DeltaSeconds, float TurningRateLimit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MovementUtils", "ComputeAngularVelocity");

	Params::MovementUtils_ComputeAngularVelocity Parms{};

	Parms.From = std::move(From);
	Parms.To = std::move(To);
	Parms.DeltaSeconds = DeltaSeconds;
	Parms.TurningRateLimit = TurningRateLimit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.MovementUtils.ComputeControlledFreeMove
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FFreeMoveParams&           InParams                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FProposedMove                    ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FProposedMove UMovementUtils::ComputeControlledFreeMove(const struct FFreeMoveParams& InParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MovementUtils", "ComputeControlledFreeMove");

	Params::MovementUtils_ComputeControlledFreeMove Parms{};

	Parms.InParams = std::move(InParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.MovementUtils.ComputeControlledGroundMove
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGroundMoveParams&         InParams                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FProposedMove                    ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FProposedMove UMovementUtils::ComputeControlledGroundMove(const struct FGroundMoveParams& InParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MovementUtils", "ComputeControlledGroundMove");

	Params::MovementUtils_ComputeControlledGroundMove Parms{};

	Parms.InParams = std::move(InParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.MovementUtils.ComputeDeflectedMoveOntoRamp
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   OrigMoveDelta                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                RampHitResult                                          (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   MaxWalkSlopeCosine                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const bool                              bHitFromLineTrace                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMovementUtils::ComputeDeflectedMoveOntoRamp(const struct FVector& OrigMoveDelta, const struct FHitResult& RampHitResult, float MaxWalkSlopeCosine, const bool bHitFromLineTrace)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MovementUtils", "ComputeDeflectedMoveOntoRamp");

	Params::MovementUtils_ComputeDeflectedMoveOntoRamp Parms{};

	Parms.OrigMoveDelta = std::move(OrigMoveDelta);
	Parms.RampHitResult = std::move(RampHitResult);
	Parms.MaxWalkSlopeCosine = MaxWalkSlopeCosine;
	Parms.bHitFromLineTrace = bHitFromLineTrace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.MovementUtils.ComputeDirectionIntent
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   MoveInput                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMoveInputType                          MoveInputType                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMovementUtils::ComputeDirectionIntent(const struct FVector& MoveInput, EMoveInputType MoveInputType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MovementUtils", "ComputeDirectionIntent");

	Params::MovementUtils_ComputeDirectionIntent Parms{};

	Parms.MoveInput = std::move(MoveInput);
	Parms.MoveInputType = MoveInputType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.MovementUtils.ComputeSlideDelta
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Delta                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const float                             PctOfDeltaToMove                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Normal                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMovementUtils::ComputeSlideDelta(const struct FVector& Delta, const float PctOfDeltaToMove, const struct FVector& Normal, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MovementUtils", "ComputeSlideDelta");

	Params::MovementUtils_ComputeSlideDelta Parms{};

	Parms.Delta = std::move(Delta);
	Parms.PctOfDeltaToMove = PctOfDeltaToMove;
	Parms.Normal = std::move(Normal);
	Parms.Hit = std::move(Hit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.MovementUtils.ComputeVelocity
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FComputeVelocityParams&    InParams                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMovementUtils::ComputeVelocity(const struct FComputeVelocityParams& InParams)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MovementUtils", "ComputeVelocity");

	Params::MovementUtils_ComputeVelocity Parms{};

	Parms.InParams = std::move(InParams);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.MovementUtils.ComputeVelocityFromGravity
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   GravityAccel                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMovementUtils::ComputeVelocityFromGravity(const struct FVector& GravityAccel, float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MovementUtils", "ComputeVelocityFromGravity");

	Params::MovementUtils_ComputeVelocityFromGravity Parms{};

	Parms.GravityAccel = std::move(GravityAccel);
	Parms.DeltaSeconds = DeltaSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.MovementUtils.ComputeVelocityFromPositions
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   FromPos                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   ToPos                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMovementUtils::ComputeVelocityFromPositions(const struct FVector& FromPos, const struct FVector& ToPos, float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MovementUtils", "ComputeVelocityFromPositions");

	Params::MovementUtils_ComputeVelocityFromPositions Parms{};

	Parms.FromPos = std::move(FromPos);
	Parms.ToPos = std::move(ToPos);
	Parms.DeltaSeconds = DeltaSeconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.MovementUtils.ConstrainToPlane
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Vector                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FPlane&                    MovementPlane                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bMaintainMagnitude                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UMovementUtils::ConstrainToPlane(const struct FVector& Vector, const struct FPlane& MovementPlane, bool bMaintainMagnitude)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MovementUtils", "ConstrainToPlane");

	Params::MovementUtils_ConstrainToPlane Parms{};

	Parms.Vector = std::move(Vector);
	Parms.MovementPlane = std::move(MovementPlane);
	Parms.bMaintainMagnitude = bMaintainMagnitude;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.MovementUtils.IsExceedingMaxSpeed
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Velocity                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InMaxSpeed                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMovementUtils::IsExceedingMaxSpeed(const struct FVector& Velocity, float InMaxSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MovementUtils", "IsExceedingMaxSpeed");

	Params::MovementUtils_IsExceedingMaxSpeed Parms{};

	Parms.Velocity = std::move(Velocity);
	Parms.InMaxSpeed = InMaxSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.MovementUtils.IsHitSurfaceWalkable
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   MaxWalkSlopeCosine                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMovementUtils::IsHitSurfaceWalkable(const struct FHitResult& Hit, float MaxWalkSlopeCosine)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MovementUtils", "IsHitSurfaceWalkable");

	Params::MovementUtils_IsHitSurfaceWalkable Parms{};

	Parms.Hit = std::move(Hit);
	Parms.MaxWalkSlopeCosine = MaxWalkSlopeCosine;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.MovementUtils.IsValidLandingSpot
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class USceneComponent*                  UpdatedComponent                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              UpdatedPrimitive                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Location                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHitResult&                Hit                                                    (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// float                                   FloorSweepDistance                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxWalkSlopeCosine                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FFloorCheckResult*               OutFloorResult                                         (Parm, OutParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMovementUtils::IsValidLandingSpot(class USceneComponent* UpdatedComponent, class UPrimitiveComponent* UpdatedPrimitive, const struct FVector& Location, const struct FHitResult& Hit, float FloorSweepDistance, float MaxWalkSlopeCosine, struct FFloorCheckResult* OutFloorResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MovementUtils", "IsValidLandingSpot");

	Params::MovementUtils_IsValidLandingSpot Parms{};

	Parms.UpdatedComponent = UpdatedComponent;
	Parms.UpdatedPrimitive = UpdatedPrimitive;
	Parms.Location = std::move(Location);
	Parms.Hit = std::move(Hit);
	Parms.FloorSweepDistance = FloorSweepDistance;
	Parms.MaxWalkSlopeCosine = MaxWalkSlopeCosine;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutFloorResult != nullptr)
		*OutFloorResult = std::move(Parms.OutFloorResult);

	return Parms.ReturnValue;
}


// Function Mover.MovementUtils.TryMoveToFallAlongSurface
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class USceneComponent*                  UpdatedComponent                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              UpdatedPrimitive                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UKinematicMoverComponent*         MoverComponent                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Delta                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PctOfDeltaToMove                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FQuat&                     Rotation                                               (ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Normal                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult*                      Hit                                                    (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bHandleImpact                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   FloorSweepDistance                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxWalkSlopeCosine                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FFloorCheckResult*               OutFloorResult                                         (Parm, OutParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FMovementRecord*                 MoveRecord                                             (Parm, OutParm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMovementUtils::TryMoveToFallAlongSurface(class USceneComponent* UpdatedComponent, class UPrimitiveComponent* UpdatedPrimitive, class UKinematicMoverComponent* MoverComponent, const struct FVector& Delta, float PctOfDeltaToMove, const struct FQuat& Rotation, const struct FVector& Normal, struct FHitResult* Hit, bool bHandleImpact, float FloorSweepDistance, float MaxWalkSlopeCosine, struct FFloorCheckResult* OutFloorResult, struct FMovementRecord* MoveRecord)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MovementUtils", "TryMoveToFallAlongSurface");

	Params::MovementUtils_TryMoveToFallAlongSurface Parms{};

	Parms.UpdatedComponent = UpdatedComponent;
	Parms.UpdatedPrimitive = UpdatedPrimitive;
	Parms.MoverComponent = MoverComponent;
	Parms.Delta = std::move(Delta);
	Parms.PctOfDeltaToMove = PctOfDeltaToMove;
	Parms.Rotation = std::move(Rotation);
	Parms.Normal = std::move(Normal);
	Parms.bHandleImpact = bHandleImpact;
	Parms.FloorSweepDistance = FloorSweepDistance;
	Parms.MaxWalkSlopeCosine = MaxWalkSlopeCosine;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Hit != nullptr)
		*Hit = std::move(Parms.Hit);

	if (OutFloorResult != nullptr)
		*OutFloorResult = std::move(Parms.OutFloorResult);

	if (MoveRecord != nullptr)
		*MoveRecord = std::move(Parms.MoveRecord);

	return Parms.ReturnValue;
}


// Function Mover.MovementUtils.TryMoveToSlideAlongSurface
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class USceneComponent*                  UpdatedComponent                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              UpdatedPrimitive                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UKinematicMoverComponent*         MoverComponent                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Delta                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PctOfDeltaToMove                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FQuat&                     Rotation                                               (ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Normal                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult*                      Hit                                                    (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bHandleImpact                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMovementRecord*                 MoveRecord                                             (Parm, OutParm, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMovementUtils::TryMoveToSlideAlongSurface(class USceneComponent* UpdatedComponent, class UPrimitiveComponent* UpdatedPrimitive, class UKinematicMoverComponent* MoverComponent, const struct FVector& Delta, float PctOfDeltaToMove, const struct FQuat& Rotation, const struct FVector& Normal, struct FHitResult* Hit, bool bHandleImpact, struct FMovementRecord* MoveRecord)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MovementUtils", "TryMoveToSlideAlongSurface");

	Params::MovementUtils_TryMoveToSlideAlongSurface Parms{};

	Parms.UpdatedComponent = UpdatedComponent;
	Parms.UpdatedPrimitive = UpdatedPrimitive;
	Parms.MoverComponent = MoverComponent;
	Parms.Delta = std::move(Delta);
	Parms.PctOfDeltaToMove = PctOfDeltaToMove;
	Parms.Rotation = std::move(Rotation);
	Parms.Normal = std::move(Normal);
	Parms.bHandleImpact = bHandleImpact;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Hit != nullptr)
		*Hit = std::move(Parms.Hit);

	if (MoveRecord != nullptr)
		*MoveRecord = std::move(Parms.MoveRecord);

	return Parms.ReturnValue;
}


// Function Mover.MovementUtils.TrySafeMoveUpdatedComponent
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class USceneComponent*                  UpdatedComponent                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              UpdatedPrimitive                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Delta                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FQuat&                     NewRotation                                            (ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSweep                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult*                      OutHit                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// ETeleportType                           Teleport                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMovementRecord*                 MoveRecord                                             (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UMovementUtils::TrySafeMoveUpdatedComponent(class USceneComponent* UpdatedComponent, class UPrimitiveComponent* UpdatedPrimitive, const struct FVector& Delta, const struct FQuat& NewRotation, bool bSweep, struct FHitResult* OutHit, ETeleportType Teleport, struct FMovementRecord* MoveRecord)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MovementUtils", "TrySafeMoveUpdatedComponent");

	Params::MovementUtils_TrySafeMoveUpdatedComponent Parms{};

	Parms.UpdatedComponent = UpdatedComponent;
	Parms.UpdatedPrimitive = UpdatedPrimitive;
	Parms.Delta = std::move(Delta);
	Parms.NewRotation = std::move(NewRotation);
	Parms.bSweep = bSweep;
	Parms.Teleport = Teleport;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	if (MoveRecord != nullptr)
		*MoveRecord = std::move(Parms.MoveRecord);

	return Parms.ReturnValue;
}


// Function Mover.MovementUtils.TryWalkToSlideAlongSurface
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class USceneComponent*                  UpdatedComponent                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              UpdatedPrimitive                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UKinematicMoverComponent*         MoverComponent                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Delta                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PctOfDeltaToMove                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FQuat&                     Rotation                                               (ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Normal                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FHitResult*                      Hit                                                    (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    bHandleImpact                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMovementRecord*                 MoveRecord                                             (Parm, OutParm, NativeAccessSpecifierPublic)
// float                                   MaxWalkSlopeCosine                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UMovementUtils::TryWalkToSlideAlongSurface(class USceneComponent* UpdatedComponent, class UPrimitiveComponent* UpdatedPrimitive, class UKinematicMoverComponent* MoverComponent, const struct FVector& Delta, float PctOfDeltaToMove, const struct FQuat& Rotation, const struct FVector& Normal, struct FHitResult* Hit, bool bHandleImpact, struct FMovementRecord* MoveRecord, float MaxWalkSlopeCosine)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MovementUtils", "TryWalkToSlideAlongSurface");

	Params::MovementUtils_TryWalkToSlideAlongSurface Parms{};

	Parms.UpdatedComponent = UpdatedComponent;
	Parms.UpdatedPrimitive = UpdatedPrimitive;
	Parms.MoverComponent = MoverComponent;
	Parms.Delta = std::move(Delta);
	Parms.PctOfDeltaToMove = PctOfDeltaToMove;
	Parms.Rotation = std::move(Rotation);
	Parms.Normal = std::move(Normal);
	Parms.bHandleImpact = bHandleImpact;
	Parms.MaxWalkSlopeCosine = MaxWalkSlopeCosine;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Hit != nullptr)
		*Hit = std::move(Parms.Hit);

	if (MoveRecord != nullptr)
		*MoveRecord = std::move(Parms.MoveRecord);

	return Parms.ReturnValue;
}


// Function Mover.PlayMoverMontageCallbackProxy.CreateProxyObjectForPlayMoverMontage
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UKinematicMoverComponent*         InMoverComponent                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     MontageToPlay                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   PlayRate                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartingPosition                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             StartingSection                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPlayMoverMontageCallbackProxy*   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPlayMoverMontageCallbackProxy* UPlayMoverMontageCallbackProxy::CreateProxyObjectForPlayMoverMontage(class UKinematicMoverComponent* InMoverComponent, class UAnimMontage* MontageToPlay, float PlayRate, float StartingPosition, class FName StartingSection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayMoverMontageCallbackProxy", "CreateProxyObjectForPlayMoverMontage");

	Params::PlayMoverMontageCallbackProxy_CreateProxyObjectForPlayMoverMontage Parms{};

	Parms.InMoverComponent = InMoverComponent;
	Parms.MontageToPlay = MontageToPlay;
	Parms.PlayRate = PlayRate;
	Parms.StartingPosition = StartingPosition;
	Parms.StartingSection = StartingSection;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function Mover.PlayMoverMontageCallbackProxy.OnMoverMontageEnded
// (Final, Native, Protected)
// Parameters:
// class FName                             IgnoredNotifyName                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayMoverMontageCallbackProxy::OnMoverMontageEnded(class FName IgnoredNotifyName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayMoverMontageCallbackProxy", "OnMoverMontageEnded");

	Params::PlayMoverMontageCallbackProxy_OnMoverMontageEnded Parms{};

	Parms.IgnoredNotifyName = IgnoredNotifyName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}

}

