#pragma once

/*
* SDK generated by Dumper-8
*
* https://github.com/NotTacs/Dumper-8
*/

// Package: JunoProceduralWorld

#include "Basic.hpp"

#include "JunoProceduralWorld_classes.hpp"
#include "JunoProceduralWorld_parameters.hpp"


namespace SDK
{

// Function JunoProceduralWorld.JunoInstancedActorComponent.HasMassEntity
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UJunoInstancedActorComponent::HasMassEntity() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoInstancedActorComponent", "HasMassEntity");

	Params::JunoInstancedActorComponent_HasMassEntity Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoInstancedActorData.GetManager
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AJunoInstancedActorManager*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AJunoInstancedActorManager* UJunoInstancedActorData::GetManager() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoInstancedActorData", "GetManager");

	Params::JunoInstancedActorData_GetManager Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoLifecycleComponent.ApplyCurrentPhaseOverrides
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void UJunoLifecycleComponent::ApplyCurrentPhaseOverrides()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoLifecycleComponent", "ApplyCurrentPhaseOverrides");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoLifecycleComponent.OnRep_CurrentPhaseIndex
// (Final, Native, Protected)
// Parameters:
// uint8                                   PreviousLifecyclePhaseIndex                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoLifecycleComponent::OnRep_CurrentPhaseIndex(uint8 PreviousLifecyclePhaseIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoLifecycleComponent", "OnRep_CurrentPhaseIndex");

	Params::JunoLifecycleComponent_OnRep_CurrentPhaseIndex Parms{};

	Parms.PreviousLifecyclePhaseIndex = PreviousLifecyclePhaseIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoLifecycleComponent.SetCurrentPhaseByIndex
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// uint8                                   NewCurrentPhaseIndex                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TimeElapsedInNewPhase                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bUpdateMass                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UJunoLifecycleComponent::SetCurrentPhaseByIndex(uint8 NewCurrentPhaseIndex, float TimeElapsedInNewPhase, bool bUpdateMass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoLifecycleComponent", "SetCurrentPhaseByIndex");

	Params::JunoLifecycleComponent_SetCurrentPhaseByIndex Parms{};

	Parms.NewCurrentPhaseIndex = NewCurrentPhaseIndex;
	Parms.TimeElapsedInNewPhase = TimeElapsedInNewPhase;
	Parms.bUpdateMass = bUpdateMass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoLifecycleComponent.BP_GetCurrentPhase
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FJunoLifecyclePhase*             OutCurrentPhase                                        (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UJunoLifecycleComponent::BP_GetCurrentPhase(struct FJunoLifecyclePhase* OutCurrentPhase) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoLifecycleComponent", "BP_GetCurrentPhase");

	Params::JunoLifecycleComponent_BP_GetCurrentPhase Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutCurrentPhase != nullptr)
		*OutCurrentPhase = std::move(Parms.OutCurrentPhase);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoLifecycleComponent.GetCurrentPhaseIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UJunoLifecycleComponent::GetCurrentPhaseIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoLifecycleComponent", "GetCurrentPhaseIndex");

	Params::JunoLifecycleComponent_GetCurrentPhaseIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoLifecycleComponent.GetCurrentPhaseTimeElapsed
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UJunoLifecycleComponent::GetCurrentPhaseTimeElapsed() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoLifecycleComponent", "GetCurrentPhaseTimeElapsed");

	Params::JunoLifecycleComponent_GetCurrentPhaseTimeElapsed Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoLifecycleComponent.HasCompletedLifecycle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UJunoLifecycleComponent::HasCompletedLifecycle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoLifecycleComponent", "HasCompletedLifecycle");

	Params::JunoLifecycleComponent_HasCompletedLifecycle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoStreamingGameplayVolume.Load
// (Native, Public, BlueprintCallable)

void AJunoStreamingGameplayVolume::Load()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoStreamingGameplayVolume", "Load");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoStreamingGameplayVolume.SetBounds
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Offset                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   Extent                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AJunoStreamingGameplayVolume::SetBounds(const struct FVector& Offset, const struct FVector& Extent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoStreamingGameplayVolume", "SetBounds");

	Params::JunoStreamingGameplayVolume_SetBounds Parms{};

	Parms.Offset = std::move(Offset);
	Parms.Extent = std::move(Extent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoStreamingGameplayVolume.Unload
// (Native, Public, BlueprintCallable)

void AJunoStreamingGameplayVolume::Unload()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoStreamingGameplayVolume", "Unload");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoTerrainGenerationSystem.FixupAllJunoLandscapeWeightmapLayers
// (Final, Native, Static, Public, BlueprintCallable)

void UJunoTerrainGenerationSystem::FixupAllJunoLandscapeWeightmapLayers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoTerrainGenerationSystem", "FixupAllJunoLandscapeWeightmapLayers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoTerrainGenerationSystem.FixupWorldLandscapeWeightmapLayers
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// const class UObject*                    WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoTerrainGenerationSystem::FixupWorldLandscapeWeightmapLayers(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoTerrainGenerationSystem", "FixupWorldLandscapeWeightmapLayers");

	Params::JunoTerrainGenerationSystem_FixupWorldLandscapeWeightmapLayers Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoTerrainGenerationSystem.OnCellActivate
// (Final, Native, Public)
// Parameters:
// const class UJunoDynamicRuntimeCell*    Cell                                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoTerrainGenerationSystem::OnCellActivate(const class UJunoDynamicRuntimeCell* Cell)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoTerrainGenerationSystem", "OnCellActivate");

	Params::JunoTerrainGenerationSystem_OnCellActivate Parms{};

	Parms.Cell = Cell;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoTerrainGenerationSystem.OnCellDeactivate
// (Final, Native, Public)
// Parameters:
// const class UJunoDynamicRuntimeCell*    Cell                                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoTerrainGenerationSystem::OnCellDeactivate(const class UJunoDynamicRuntimeCell* Cell)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoTerrainGenerationSystem", "OnCellDeactivate");

	Params::JunoTerrainGenerationSystem_OnCellDeactivate Parms{};

	Parms.Cell = Cell;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoTerrainGenerationSystem.OnCellLoad
// (Final, Native, Public)
// Parameters:
// const class UJunoDynamicRuntimeCell*    Cell                                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoTerrainGenerationSystem::OnCellLoad(const class UJunoDynamicRuntimeCell* Cell)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoTerrainGenerationSystem", "OnCellLoad");

	Params::JunoTerrainGenerationSystem_OnCellLoad Parms{};

	Parms.Cell = Cell;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoTerrainGenerationSystem.OnCellUnload
// (Final, Native, Public)
// Parameters:
// const class UJunoDynamicRuntimeCell*    Cell                                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoTerrainGenerationSystem::OnCellUnload(const class UJunoDynamicRuntimeCell* Cell)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoTerrainGenerationSystem", "OnCellUnload");

	Params::JunoTerrainGenerationSystem_OnCellUnload Parms{};

	Parms.Cell = Cell;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoTerrainGenerationSystem.OnProxyDestroyed
// (Final, Native, Private)
// Parameters:
// class AActor*                           DestroyedActor                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoTerrainGenerationSystem::OnProxyDestroyed(class AActor* DestroyedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoTerrainGenerationSystem", "OnProxyDestroyed");

	Params::JunoTerrainGenerationSystem_OnProxyDestroyed Parms{};

	Parms.DestroyedActor = DestroyedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoWaterSplineInjector.ForceWaterUpdate
// (Final, Native, Public, BlueprintCallable)

void UJunoWaterSplineInjector::ForceWaterUpdate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoWaterSplineInjector", "ForceWaterUpdate");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoWaterSplineInjector.InjectSplineGuideIntoWaterBody
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FJunoWaterSplineInjectorParams&Params_0                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UJunoWaterSplineInjector::InjectSplineGuideIntoWaterBody(const struct FJunoWaterSplineInjectorParams& Params_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoWaterSplineInjector", "InjectSplineGuideIntoWaterBody");

	Params::JunoWaterSplineInjector_InjectSplineGuideIntoWaterBody Parms{};

	Parms.Params_0 = std::move(Params_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.LandmassPathfinder.AdditionalPushFrontierResultCondition
// (Native, Event, Protected, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// EPushFrontierResult                     ResultFromLastPush                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLandmassPathfinderRules&  InCurrentRules                                         (Parm, NativeAccessSpecifierPublic)
// const struct FVector&                   InHome                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   InDestination                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   InCurrentLocation                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InCurrentPushSteps                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InCurrentCost                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bShouldUseBestNodeInsteadOfMostRecentNode              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPushFrontierResult                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPushFrontierResult ULandmassPathfinder::AdditionalPushFrontierResultCondition(EPushFrontierResult ResultFromLastPush, const struct FLandmassPathfinderRules& InCurrentRules, const struct FVector& InHome, const struct FVector& InDestination, const struct FVector& InCurrentLocation, int32 InCurrentPushSteps, float InCurrentCost, bool* bShouldUseBestNodeInsteadOfMostRecentNode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassPathfinder", "AdditionalPushFrontierResultCondition");

	Params::LandmassPathfinder_AdditionalPushFrontierResultCondition Parms{};

	Parms.ResultFromLastPush = ResultFromLastPush;
	Parms.InCurrentRules = std::move(InCurrentRules);
	Parms.InHome = std::move(InHome);
	Parms.InDestination = std::move(InDestination);
	Parms.InCurrentLocation = std::move(InCurrentLocation);
	Parms.InCurrentPushSteps = InCurrentPushSteps;
	Parms.InCurrentCost = InCurrentCost;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bShouldUseBestNodeInsteadOfMostRecentNode != nullptr)
		*bShouldUseBestNodeInsteadOfMostRecentNode = Parms.bShouldUseBestNodeInsteadOfMostRecentNode;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassPathfinder.ExecutePathfinderSync
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   A                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   B                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>*                 Locations                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<float>*                          Costs                                                  (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void ULandmassPathfinder::ExecutePathfinderSync(const struct FVector& A, const struct FVector& B, TArray<struct FVector>* Locations, TArray<float>* Costs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassPathfinder", "ExecutePathfinderSync");

	Params::LandmassPathfinder_ExecutePathfinderSync Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Locations != nullptr)
		*Locations = std::move(Parms.Locations);

	if (Costs != nullptr)
		*Costs = std::move(Parms.Costs);
}


// Function JunoProceduralWorld.LandmassPathfinder.FindNearestValidLocation
// (Final, Native, Protected, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   InLocation                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector*                         OutValidLocation                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bShouldProject                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULandmassPathfinder::FindNearestValidLocation(const struct FVector& InLocation, struct FVector* OutValidLocation, bool bShouldProject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassPathfinder", "FindNearestValidLocation");

	Params::LandmassPathfinder_FindNearestValidLocation Parms{};

	Parms.InLocation = std::move(InLocation);
	Parms.bShouldProject = bShouldProject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValidLocation != nullptr)
		*OutValidLocation = std::move(Parms.OutValidLocation);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassPathfinder.Initialize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ALandscapeProxy*                  LandscapeProxy_0                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALandmassProceduralRoute*         InRoute                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLandmassPathfinderRules&  Rules                                                  (Parm, NativeAccessSpecifierPublic)
// const TArray<class ULandmassPathfinder*>&InBackStopPaths                                        (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class ALandmassProceduralRoute*         InBlockingRoute                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULandmassPathfinder::Initialize(class ALandscapeProxy* LandscapeProxy_0, class ALandmassProceduralRoute* InRoute, const struct FLandmassPathfinderRules& Rules, const TArray<class ULandmassPathfinder*>& InBackStopPaths, class ALandmassProceduralRoute* InBlockingRoute)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassPathfinder", "Initialize");

	Params::LandmassPathfinder_Initialize Parms{};

	Parms.LandscapeProxy_0 = LandscapeProxy_0;
	Parms.InRoute = InRoute;
	Parms.Rules = std::move(Rules);
	Parms.InBackStopPaths = std::move(InBackStopPaths);
	Parms.InBlockingRoute = InBlockingRoute;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassPathfinder.IsTargetLocationValid
// (Native, Event, Protected, HasDefaults, BlueprintEvent)
// Parameters:
// const struct FVector&                   TargetLocation                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULandmassPathfinder::IsTargetLocationValid(const struct FVector& TargetLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassPathfinder", "IsTargetLocationValid");

	Params::LandmassPathfinder_IsTargetLocationValid Parms{};

	Parms.TargetLocation = std::move(TargetLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassPathfinder.K2_GetPriorityList
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FVector>*                 Locations                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<float>*                          Costs                                                  (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)

void ULandmassPathfinder::K2_GetPriorityList(TArray<struct FVector>* Locations, TArray<float>* Costs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassPathfinder", "K2_GetPriorityList");

	Params::LandmassPathfinder_K2_GetPriorityList Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Locations != nullptr)
		*Locations = std::move(Parms.Locations);

	if (Costs != nullptr)
		*Costs = std::move(Parms.Costs);
}


// Function JunoProceduralWorld.LandmassPathfinder.K2_StepPathfinder
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FVector>*                 OutLocations                                           (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<float>*                          OutCosts                                               (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<bool>*                           bOutIsSnapped                                          (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<EPathfinderNodeState>*           OutNodeStates                                          (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// EPushFrontierResult                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPushFrontierResult ULandmassPathfinder::K2_StepPathfinder(TArray<struct FVector>* OutLocations, TArray<float>* OutCosts, TArray<bool>* bOutIsSnapped, TArray<EPathfinderNodeState>* OutNodeStates)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassPathfinder", "K2_StepPathfinder");

	Params::LandmassPathfinder_K2_StepPathfinder Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutLocations != nullptr)
		*OutLocations = std::move(Parms.OutLocations);

	if (OutCosts != nullptr)
		*OutCosts = std::move(Parms.OutCosts);

	if (bOutIsSnapped != nullptr)
		*bOutIsSnapped = std::move(Parms.bOutIsSnapped);

	if (OutNodeStates != nullptr)
		*OutNodeStates = std::move(Parms.OutNodeStates);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassPathfinder.OnInitialize
// (Event, Public, BlueprintEvent)
// Parameters:
// class ALandscapeProxy*                  InLandscapeProxy                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ALandmassProceduralRoute*         InRoute                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLandmassPathfinderRules&  Rules                                                  (Parm, NativeAccessSpecifierPublic)
// class ALandmassProceduralRoute*         InBlockingRoute                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULandmassPathfinder::OnInitialize(class ALandscapeProxy* InLandscapeProxy, class ALandmassProceduralRoute* InRoute, const struct FLandmassPathfinderRules& Rules, class ALandmassProceduralRoute* InBlockingRoute)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassPathfinder", "OnInitialize");

	Params::LandmassPathfinder_OnInitialize Parms{};

	Parms.InLandscapeProxy = InLandscapeProxy;
	Parms.InRoute = InRoute;
	Parms.Rules = std::move(Rules);
	Parms.InBlockingRoute = InBlockingRoute;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.LandmassPathfinder.OnStartPathfinder
// (Event, Public, HasDefaults, BlueprintEvent)
// Parameters:
// const struct FVector&                   A                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   B                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULandmassPathfinder::OnStartPathfinder(const struct FVector& A, const struct FVector& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassPathfinder", "OnStartPathfinder");

	Params::LandmassPathfinder_OnStartPathfinder Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.LandmassPathfinder.SetDestination
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Location                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULandmassPathfinder::SetDestination(const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassPathfinder", "SetDestination");

	Params::LandmassPathfinder_SetDestination Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.LandmassPathfinder.SetDestinationActuallyReached
// (Final, Native, Protected, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULandmassPathfinder::SetDestinationActuallyReached(const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassPathfinder", "SetDestinationActuallyReached");

	Params::LandmassPathfinder_SetDestinationActuallyReached Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.LandmassPathfinder.StartPathfinder
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   A                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   B                                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULandmassPathfinder::StartPathfinder(const struct FVector& A, const struct FVector& B)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassPathfinder", "StartPathfinder");

	Params::LandmassPathfinder_StartPathfinder Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.LandmassPathfinder.GetIsInitialized
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULandmassPathfinder::GetIsInitialized() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassPathfinder", "GetIsInitialized");

	Params::LandmassPathfinder_GetIsInitialized Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassPathfinder.GetLandscapeBox
// (Final, Native, Protected, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FBox                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FBox ULandmassPathfinder::GetLandscapeBox() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassPathfinder", "GetLandscapeBox");

	Params::LandmassPathfinder_GetLandscapeBox Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassPathfinder.ProjectLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bOutIsValidLocation                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector ULandmassPathfinder::ProjectLocation(const struct FVector& Location, bool* bOutIsValidLocation) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassPathfinder", "ProjectLocation");

	Params::LandmassPathfinder_ProjectLocation Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bOutIsValidLocation != nullptr)
		*bOutIsValidLocation = Parms.bOutIsValidLocation;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.PathfinderGuideSetsDataAsset.LoadCurveSetAndAddSplineComponentsToActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           InActor                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPathfinderGuideSetsDataAsset::LoadCurveSetAndAddSplineComponentsToActor(class AActor* InActor, int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PathfinderGuideSetsDataAsset", "LoadCurveSetAndAddSplineComponentsToActor");

	Params::PathfinderGuideSetsDataAsset_LoadCurveSetAndAddSplineComponentsToActor Parms{};

	Parms.InActor = InActor;
	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.PathfinderGuideSetsDataAsset.SaveCurveSetFromSplintComponents
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const TArray<class USplineComponent*>&  SourceComponents                                       (Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPathfinderGuideSetsDataAsset::SaveCurveSetFromSplintComponents(const TArray<class USplineComponent*>& SourceComponents, int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PathfinderGuideSetsDataAsset", "SaveCurveSetFromSplintComponents");

	Params::PathfinderGuideSetsDataAsset_SaveCurveSetFromSplintComponents Parms{};

	Parms.SourceComponents = std::move(SourceComponents);
	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.PathfinderGuideSetsDataAsset.GetRandomGuideSet
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FPathfinderGuideSet              ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FPathfinderGuideSet UPathfinderGuideSetsDataAsset::GetRandomGuideSet() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PathfinderGuideSetsDataAsset", "GetRandomGuideSet");

	Params::PathfinderGuideSetsDataAsset_GetRandomGuideSet Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.PathfinderGuideSetsDataAsset.GetRandomGuideSetFromSeed
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   Seed                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPathfinderGuideSet              ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FPathfinderGuideSet UPathfinderGuideSetsDataAsset::GetRandomGuideSetFromSeed(int32 Seed) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PathfinderGuideSetsDataAsset", "GetRandomGuideSetFromSeed");

	Params::PathfinderGuideSetsDataAsset_GetRandomGuideSetFromSeed Parms{};

	Parms.Seed = Seed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoLevelInstance.GetActorsInLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> AJunoLevelInstance::GetActorsInLevel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoLevelInstance", "GetActorsInLevel");

	Params::JunoLevelInstance_GetActorsInLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.JunoLivingWorldStaticPointProvider.AppendFiltersTags
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayTagContainer&     Container                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void AJunoLivingWorldStaticPointProvider::AppendFiltersTags(const struct FGameplayTagContainer& Container)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JunoLivingWorldStaticPointProvider", "AppendFiltersTags");

	Params::JunoLivingWorldStaticPointProvider_AppendFiltersTags Parms{};

	Parms.Container = std::move(Container);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.JunoPOIBlueprintLibrary.CreateCavePOI
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class AActor*                     CaveSlotActor                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGuid&                     CaveSlotGuid                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGuid&                     CaveShellGuid                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FJunoPOIData&              Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EGeneratePOIResult*                     Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoPOIBlueprintLibrary::CreateCavePOI(const class AActor* CaveSlotActor, const struct FGuid& CaveSlotGuid, const struct FGuid& CaveShellGuid, const struct FJunoPOIData& Data, EGeneratePOIResult* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoPOIBlueprintLibrary", "CreateCavePOI");

	Params::JunoPOIBlueprintLibrary_CreateCavePOI Parms{};

	Parms.CaveSlotActor = CaveSlotActor;
	Parms.CaveSlotGuid = std::move(CaveSlotGuid);
	Parms.CaveShellGuid = std::move(CaveShellGuid);
	Parms.Data = std::move(Data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function JunoProceduralWorld.JunoPOIBlueprintLibrary.CreatePOI
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class AActor*                     POISlotActor                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGuid&                     POISlotGuid                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FJunoPOIData&              Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// EGeneratePOIResult*                     Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoPOIBlueprintLibrary::CreatePOI(const class AActor* POISlotActor, const struct FGuid& POISlotGuid, const struct FJunoPOIData& Data, EGeneratePOIResult* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoPOIBlueprintLibrary", "CreatePOI");

	Params::JunoPOIBlueprintLibrary_CreatePOI Parms{};

	Parms.POISlotActor = POISlotActor;
	Parms.POISlotGuid = std::move(POISlotGuid);
	Parms.Data = std::move(Data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function JunoProceduralWorld.JunoPOIBlueprintLibrary.CreateRarePOIs
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class AActor*                     Actor                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRandomStream&             RandomStream                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// const struct FDataRegistryType&         DataRegistry                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FJunoPOIManagerSlot>&     PotentialSlots                                         (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FJunoPOIManagerSlot>*     UsedSlots                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// EGeneratePOIResult*                     Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoPOIBlueprintLibrary::CreateRarePOIs(const class AActor* Actor, const struct FRandomStream& RandomStream, const struct FDataRegistryType& DataRegistry, TArray<struct FJunoPOIManagerSlot>& PotentialSlots, TArray<struct FJunoPOIManagerSlot>* UsedSlots, EGeneratePOIResult* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoPOIBlueprintLibrary", "CreateRarePOIs");

	Params::JunoPOIBlueprintLibrary_CreateRarePOIs Parms{};

	Parms.Actor = Actor;
	Parms.RandomStream = std::move(RandomStream);
	Parms.DataRegistry = std::move(DataRegistry);
	Parms.PotentialSlots = std::move(PotentialSlots);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	PotentialSlots = std::move(Parms.PotentialSlots);

	if (UsedSlots != nullptr)
		*UsedSlots = std::move(Parms.UsedSlots);

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function JunoProceduralWorld.JunoPOIBlueprintLibrary.FindBestPOISlots
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const TArray<struct FJunoPOIManagerSlot>&PotentialSlots                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<struct FJunoPOIManagerSlot>&AdditionalCompareSlots                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   DesiredNumber                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  DesiredMinDistance                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FJunoPOIManagerSlot>*     Result                                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<struct FJunoPOIManagerSlot>*     Remainder                                              (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// const struct FBox&                      WorldTileBounds                                        (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// EJunoBiome                              Biome                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bEnforceMinDistance                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoPOIBlueprintLibrary::FindBestPOISlots(const TArray<struct FJunoPOIManagerSlot>& PotentialSlots, const TArray<struct FJunoPOIManagerSlot>& AdditionalCompareSlots, int32 DesiredNumber, double DesiredMinDistance, TArray<struct FJunoPOIManagerSlot>* Result, TArray<struct FJunoPOIManagerSlot>* Remainder, const struct FBox& WorldTileBounds, EJunoBiome Biome, bool bEnforceMinDistance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoPOIBlueprintLibrary", "FindBestPOISlots");

	Params::JunoPOIBlueprintLibrary_FindBestPOISlots Parms{};

	Parms.PotentialSlots = std::move(PotentialSlots);
	Parms.AdditionalCompareSlots = std::move(AdditionalCompareSlots);
	Parms.DesiredNumber = DesiredNumber;
	Parms.DesiredMinDistance = DesiredMinDistance;
	Parms.WorldTileBounds = std::move(WorldTileBounds);
	Parms.Biome = Biome;
	Parms.bEnforceMinDistance = bEnforceMinDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = std::move(Parms.Result);

	if (Remainder != nullptr)
		*Remainder = std::move(Parms.Remainder);
}


// Function JunoProceduralWorld.JunoPOIBlueprintLibrary.GetMatchingPOIsFromDataRegistry
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FDataRegistryType&         DataRegistry                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TSet<class FName>&                Tags                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const TSet<EJunoPOISize>&               Sizes                                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const TSet<EJunoBiome>&                 Biomes                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// const TArray<struct FPCGJunoWorldTilePOI>&Array                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// EJunoGetMatchingPOIsFromDataRegistryResult*Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EJunoWorldTilePOIType                   Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoPOIBlueprintLibrary::GetMatchingPOIsFromDataRegistry(const struct FDataRegistryType& DataRegistry, const TSet<class FName>& Tags, const TSet<EJunoPOISize>& Sizes, const TSet<EJunoBiome>& Biomes, const TArray<struct FPCGJunoWorldTilePOI>& Array, EJunoGetMatchingPOIsFromDataRegistryResult* Result, EJunoWorldTilePOIType Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoPOIBlueprintLibrary", "GetMatchingPOIsFromDataRegistry");

	Params::JunoPOIBlueprintLibrary_GetMatchingPOIsFromDataRegistry Parms{};

	Parms.DataRegistry = std::move(DataRegistry);
	Parms.Tags = std::move(Tags);
	Parms.Sizes = std::move(Sizes);
	Parms.Biomes = std::move(Biomes);
	Parms.Array = std::move(Array);
	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function JunoProceduralWorld.JunoPOIBlueprintLibrary.MarkCavePOISlotUnused
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class AActor*                     CaveSlotActor                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGuid&                     CaveSlotGuid                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGuid&                     CaveShellGuid                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EJunoMarkSlotPOIUnusedResult*           Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoPOIBlueprintLibrary::MarkCavePOISlotUnused(const class AActor* CaveSlotActor, const struct FGuid& CaveSlotGuid, const struct FGuid& CaveShellGuid, EJunoMarkSlotPOIUnusedResult* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoPOIBlueprintLibrary", "MarkCavePOISlotUnused");

	Params::JunoPOIBlueprintLibrary_MarkCavePOISlotUnused Parms{};

	Parms.CaveSlotActor = CaveSlotActor;
	Parms.CaveSlotGuid = std::move(CaveSlotGuid);
	Parms.CaveShellGuid = std::move(CaveShellGuid);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function JunoProceduralWorld.JunoPOIBlueprintLibrary.MarkPOISlotUnused
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class AActor*                     POISlotActor                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGuid&                     POISlotGuid                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EJunoMarkSlotPOIUnusedResult*           Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoPOIBlueprintLibrary::MarkPOISlotUnused(const class AActor* POISlotActor, const struct FGuid& POISlotGuid, EJunoMarkSlotPOIUnusedResult* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoPOIBlueprintLibrary", "MarkPOISlotUnused");

	Params::JunoPOIBlueprintLibrary_MarkPOISlotUnused Parms{};

	Parms.POISlotActor = POISlotActor;
	Parms.POISlotGuid = std::move(POISlotGuid);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function JunoProceduralWorld.JunoPOIBlueprintLibrary.QueryCavePOIState
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class AActor*                     CaveSlotActor                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGuid&                     CaveSlotGuid                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGuid&                     CaveShellGuid                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EQueryPOIStateResult*                   Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBox*                            WorldTileBounds                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UJunoPOIBlueprintLibrary::QueryCavePOIState(const class AActor* CaveSlotActor, const struct FGuid& CaveSlotGuid, const struct FGuid& CaveShellGuid, EQueryPOIStateResult* Result, struct FBox* WorldTileBounds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoPOIBlueprintLibrary", "QueryCavePOIState");

	Params::JunoPOIBlueprintLibrary_QueryCavePOIState Parms{};

	Parms.CaveSlotActor = CaveSlotActor;
	Parms.CaveSlotGuid = std::move(CaveSlotGuid);
	Parms.CaveShellGuid = std::move(CaveShellGuid);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;

	if (WorldTileBounds != nullptr)
		*WorldTileBounds = std::move(Parms.WorldTileBounds);
}


// Function JunoProceduralWorld.JunoPOIBlueprintLibrary.QueryPOIState
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// const class AActor*                     POISlotActor                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGuid&                     POISlotGuid                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EQueryPOIStateResult*                   Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FJunoPOISlotMetaData*            POISlotMetaData                                        (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FBox*                            WorldTileBounds                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UJunoPOIBlueprintLibrary::QueryPOIState(const class AActor* POISlotActor, const struct FGuid& POISlotGuid, EQueryPOIStateResult* Result, struct FJunoPOISlotMetaData* POISlotMetaData, struct FBox* WorldTileBounds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoPOIBlueprintLibrary", "QueryPOIState");

	Params::JunoPOIBlueprintLibrary_QueryPOIState Parms{};

	Parms.POISlotActor = POISlotActor;
	Parms.POISlotGuid = std::move(POISlotGuid);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;

	if (POISlotMetaData != nullptr)
		*POISlotMetaData = std::move(Parms.POISlotMetaData);

	if (WorldTileBounds != nullptr)
		*WorldTileBounds = std::move(Parms.WorldTileBounds);
}


// Function JunoProceduralWorld.JunoPOIBlueprintLibrary.SetPOISlotMetaDatas
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const class AActor*                     POISlotActor                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FJunoPOIManagerSlot>&POISlots                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// const struct FJunoPOISlotMetaData&      POISlotMetaData                                        (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// EJunoSetSlotPOIMetaDataResult*          Result                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJunoPOIBlueprintLibrary::SetPOISlotMetaDatas(const class AActor* POISlotActor, const TArray<struct FJunoPOIManagerSlot>& POISlots, const struct FJunoPOISlotMetaData& POISlotMetaData, EJunoSetSlotPOIMetaDataResult* Result)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JunoPOIBlueprintLibrary", "SetPOISlotMetaDatas");

	Params::JunoPOIBlueprintLibrary_SetPOISlotMetaDatas Parms{};

	Parms.POISlotActor = POISlotActor;
	Parms.POISlots = std::move(POISlots);
	Parms.POISlotMetaData = std::move(POISlotMetaData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Result != nullptr)
		*Result = Parms.Result;
}


// Function JunoProceduralWorld.LandmassCluster.InitializeDentrogram
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<class AActor*>&            InActors                                               (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// const TArray<struct FDendrogramLeafAttributes>&InAttributes                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ULandmassCluster::InitializeDentrogram(const TArray<class AActor*>& InActors, const TArray<struct FDendrogramLeafAttributes>& InAttributes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassCluster", "InitializeDentrogram");

	Params::LandmassCluster_InitializeDentrogram Parms{};

	Parms.InActors = std::move(InActors);
	Parms.InAttributes = std::move(InAttributes);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.LandmassCluster.K2_AddConnection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           LeafActorA                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           LeafActorB                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULandmassCluster::K2_AddConnection(class AActor* LeafActorA, class AActor* LeafActorB)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassCluster", "K2_AddConnection");

	Params::LandmassCluster_K2_AddConnection Parms{};

	Parms.LeafActorA = LeafActorA;
	Parms.LeafActorB = LeafActorB;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassCluster.GetClustersAtLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   InLevel                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FDendrogramClusterOutput>ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

const TArray<struct FDendrogramClusterOutput> ULandmassCluster::GetClustersAtLevel(int32 InLevel) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassCluster", "GetClustersAtLevel");

	Params::LandmassCluster_GetClustersAtLevel Parms{};

	Parms.InLevel = InLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassCluster.GetLeafCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULandmassCluster::GetLeafCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassCluster", "GetLeafCount");

	Params::LandmassCluster_GetLeafCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassCluster.GetTopLevel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULandmassCluster::GetTopLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassCluster", "GetTopLevel");

	Params::LandmassCluster_GetTopLevel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRouteDefinition.FindLocationClosestToWorldLocation
// (Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector&                   WorldLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float*                                  OutDistanceSqr                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UProceduralRouteDefinition::FindLocationClosestToWorldLocation(const struct FVector& WorldLocation, float* OutDistanceSqr) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralRouteDefinition", "FindLocationClosestToWorldLocation");

	Params::ProceduralRouteDefinition_FindLocationClosestToWorldLocation Parms{};

	Parms.WorldLocation = std::move(WorldLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutDistanceSqr != nullptr)
		*OutDistanceSqr = Parms.OutDistanceSqr;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassProceduralRoute.AddAvoidancePrimitive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FRouteAvoidancePrimitive&  InPrimitive                                            (ConstParm, Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ALandmassProceduralRoute::AddAvoidancePrimitive(const struct FRouteAvoidancePrimitive& InPrimitive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassProceduralRoute", "AddAvoidancePrimitive");

	Params::LandmassProceduralRoute_AddAvoidancePrimitive Parms{};

	Parms.InPrimitive = std::move(InPrimitive);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.LandmassProceduralRoute.AddConnection
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class AActor*                           LeafActorA                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           LeafActorB                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALandmassProceduralRoute::AddConnection(class AActor* LeafActorA, class AActor* LeafActorB)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassProceduralRoute", "AddConnection");

	Params::LandmassProceduralRoute_AddConnection Parms{};

	Parms.LeafActorA = LeafActorA;
	Parms.LeafActorB = LeafActorB;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassProceduralRoute.AddControlPoint
// (Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   WorldPosition                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALandmassProceduralRoute::AddControlPoint(const struct FVector& WorldPosition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassProceduralRoute", "AddControlPoint");

	Params::LandmassProceduralRoute_AddControlPoint Parms{};

	Parms.WorldPosition = std::move(WorldPosition);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassProceduralRoute.BeginGeneratePCG
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const TArray<struct FLandmassPCGRouteInput>&Inputs                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ALandmassProceduralRoute::BeginGeneratePCG(const TArray<struct FLandmassPCGRouteInput>& Inputs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassProceduralRoute", "BeginGeneratePCG");

	Params::LandmassProceduralRoute_BeginGeneratePCG Parms{};

	Parms.Inputs = std::move(Inputs);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.LandmassProceduralRoute.CustomTick
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   DeltaSeconds                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALandmassProceduralRoute::CustomTick(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassProceduralRoute", "CustomTick");

	Params::LandmassProceduralRoute_CustomTick Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JunoProceduralWorld.LandmassProceduralRoute.FinishRoute
// (Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// int32*                                  OutRouteIndex                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALandmassProceduralRoute::FinishRoute(int32* OutRouteIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassProceduralRoute", "FinishRoute");

	Params::LandmassProceduralRoute_FinishRoute Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutRouteIndex != nullptr)
		*OutRouteIndex = Parms.OutRouteIndex;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassProceduralRoute.GenerateCluster
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALandmassProceduralRoute::GenerateCluster()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassProceduralRoute", "GenerateCluster");

	Params::LandmassProceduralRoute_GenerateCluster Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassProceduralRoute.InitLandmassCluster
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<class AActor*>&            InActors                                               (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// const TArray<struct FDendrogramLeafAttributes>&InLeafAttributes                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ALandmassProceduralRoute::InitLandmassCluster(const TArray<class AActor*>& InActors, const TArray<struct FDendrogramLeafAttributes>& InLeafAttributes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassProceduralRoute", "InitLandmassCluster");

	Params::LandmassProceduralRoute_InitLandmassCluster Parms{};

	Parms.InActors = std::move(InActors);
	Parms.InLeafAttributes = std::move(InLeafAttributes);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.LandmassProceduralRoute.InitLandmassClusterLeavesOnly
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// const TArray<struct FDendrogramLeafAttributes>&InLeafAttributes                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ALandmassProceduralRoute::InitLandmassClusterLeavesOnly(const TArray<struct FDendrogramLeafAttributes>& InLeafAttributes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassProceduralRoute", "InitLandmassClusterLeavesOnly");

	Params::LandmassProceduralRoute_InitLandmassClusterLeavesOnly Parms{};

	Parms.InLeafAttributes = std::move(InLeafAttributes);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.LandmassProceduralRoute.OnGenerationFinished
// (Final, Native, Public, BlueprintCallable)

void ALandmassProceduralRoute::OnGenerationFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassProceduralRoute", "OnGenerationFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.LandmassProceduralRoute.PutIntoDormancy
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALandmassProceduralRoute::PutIntoDormancy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassProceduralRoute", "PutIntoDormancy");

	Params::LandmassProceduralRoute_PutIntoDormancy Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassProceduralRoute.RasterizeAllPendingRoutesToRouteGrid
// (Final, Native, Public, BlueprintCallable)

void ALandmassProceduralRoute::RasterizeAllPendingRoutesToRouteGrid()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassProceduralRoute", "RasterizeAllPendingRoutesToRouteGrid");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.LandmassProceduralRoute.ResetAllAndInitialize
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bResetAllLandscapeSplines                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALandmassProceduralRoute::ResetAllAndInitialize(bool bResetAllLandscapeSplines)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassProceduralRoute", "ResetAllAndInitialize");

	Params::LandmassProceduralRoute_ResetAllAndInitialize Parms{};

	Parms.bResetAllLandscapeSplines = bResetAllLandscapeSplines;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassProceduralRoute.SetCurrentRouteGenerationState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ERouteGenerationState                   InState                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALandmassProceduralRoute::SetCurrentRouteGenerationState(ERouteGenerationState InState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassProceduralRoute", "SetCurrentRouteGenerationState");

	Params::LandmassProceduralRoute_SetCurrentRouteGenerationState Parms{};

	Parms.InState = InState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.LandmassProceduralRoute.SetEditorTickEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALandmassProceduralRoute::SetEditorTickEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassProceduralRoute", "SetEditorTickEnabled");

	Params::LandmassProceduralRoute_SetEditorTickEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.LandmassProceduralRoute.SetWidthAtPointIndex
// (Native, Public, BlueprintCallable)
// Parameters:
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewWidth                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALandmassProceduralRoute::SetWidthAtPointIndex(int32 Index_0, float NewWidth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassProceduralRoute", "SetWidthAtPointIndex");

	Params::LandmassProceduralRoute_SetWidthAtPointIndex Parms{};

	Parms.Index_0 = Index_0;
	Parms.NewWidth = NewWidth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.LandmassProceduralRoute.SetWidthForLastAddedPoint
// (Native, Public, BlueprintCallable)
// Parameters:
// float                                   NewWidth                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALandmassProceduralRoute::SetWidthForLastAddedPoint(float NewWidth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassProceduralRoute", "SetWidthForLastAddedPoint");

	Params::LandmassProceduralRoute_SetWidthForLastAddedPoint Parms{};

	Parms.NewWidth = NewWidth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.LandmassProceduralRoute.StartRoute
// (Native, Public, BlueprintCallable)

void ALandmassProceduralRoute::StartRoute()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassProceduralRoute", "StartRoute");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.LandmassProceduralRoute.WakeUpDormantRoute
// (Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALandmassProceduralRoute::WakeUpDormantRoute()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassProceduralRoute", "WakeUpDormantRoute");

	Params::LandmassProceduralRoute_WakeUpDormantRoute Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassProceduralRoute.GetCurrentRouteGenerationState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ERouteGenerationState                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ERouteGenerationState ALandmassProceduralRoute::GetCurrentRouteGenerationState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassProceduralRoute", "GetCurrentRouteGenerationState");

	Params::LandmassProceduralRoute_GetCurrentRouteGenerationState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassProceduralRoute.GetLandmassCluster
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ULandmassCluster*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULandmassCluster* ALandmassProceduralRoute::GetLandmassCluster() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassProceduralRoute", "GetLandmassCluster");

	Params::LandmassProceduralRoute_GetLandmassCluster Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassProceduralRoute.GetRouteDefinitions
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UProceduralRouteDefinition*>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UProceduralRouteDefinition*> ALandmassProceduralRoute::GetRouteDefinitions() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassProceduralRoute", "GetRouteDefinitions");

	Params::LandmassProceduralRoute_GetRouteDefinitions Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassProceduralRoute.IsInsideAnyLake
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Tolerance                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALandmassProceduralRoute::IsInsideAnyLake(const struct FVector& Location, float Tolerance) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassProceduralRoute", "IsInsideAnyLake");

	Params::LandmassProceduralRoute_IsInsideAnyLake Parms{};

	Parms.Location = std::move(Location);
	Parms.Tolerance = Tolerance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassProceduralRoute.IsInsideLake
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector&                   Location                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class AWaterBody*                 InLake                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Dilation                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALandmassProceduralRoute::IsInsideLake(const struct FVector& Location, const class AWaterBody* InLake, float Dilation) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassProceduralRoute", "IsInsideLake");

	Params::LandmassProceduralRoute_IsInsideLake Parms{};

	Parms.Location = std::move(Location);
	Parms.InLake = InLake;
	Parms.Dilation = Dilation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.LandmassProceduralRoute.IsInsideOcean
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector&                   Location                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ALandmassProceduralRoute::IsInsideOcean(const struct FVector& Location) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LandmassProceduralRoute", "IsInsideOcean");

	Params::LandmassProceduralRoute_IsInsideOcean Parms{};

	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRiverDefinition.GetWaterBodyActor
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AWaterBody*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AWaterBody* UProceduralRiverDefinition::GetWaterBodyActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralRiverDefinition", "GetWaterBodyActor");

	Params::ProceduralRiverDefinition_GetWaterBodyActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRiverDefinition.GetWaterSpline
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UWaterSplineComponent*            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UWaterSplineComponent* UProceduralRiverDefinition::GetWaterSpline() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralRiverDefinition", "GetWaterSpline");

	Params::ProceduralRiverDefinition_GetWaterSpline Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRivers.GetAudioIntensityAtDistanceAlongSpline
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UWaterSplineComponent*            WaterSplineComponent                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DistanceAlongSpline                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AProceduralRivers::GetAudioIntensityAtDistanceAlongSpline(class UWaterSplineComponent* WaterSplineComponent, float DistanceAlongSpline)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ProceduralRivers", "GetAudioIntensityAtDistanceAlongSpline");

	Params::ProceduralRivers_GetAudioIntensityAtDistanceAlongSpline Parms{};

	Parms.WaterSplineComponent = WaterSplineComponent;
	Parms.DistanceAlongSpline = DistanceAlongSpline;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRivers.GetDepthAtDistanceAlongSpline
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UWaterSplineComponent*            WaterSplineComponent                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DistanceAlongSpline                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AProceduralRivers::GetDepthAtDistanceAlongSpline(class UWaterSplineComponent* WaterSplineComponent, float DistanceAlongSpline)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ProceduralRivers", "GetDepthAtDistanceAlongSpline");

	Params::ProceduralRivers_GetDepthAtDistanceAlongSpline Parms{};

	Parms.WaterSplineComponent = WaterSplineComponent;
	Parms.DistanceAlongSpline = DistanceAlongSpline;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRivers.GetHalfWidthAtDistanceAlongSpline
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UWaterSplineComponent*            WaterSplineComponent                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DistanceAlongSpline                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AProceduralRivers::GetHalfWidthAtDistanceAlongSpline(class UWaterSplineComponent* WaterSplineComponent, float DistanceAlongSpline)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ProceduralRivers", "GetHalfWidthAtDistanceAlongSpline");

	Params::ProceduralRivers_GetHalfWidthAtDistanceAlongSpline Parms{};

	Parms.WaterSplineComponent = WaterSplineComponent;
	Parms.DistanceAlongSpline = DistanceAlongSpline;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRivers.GetProceduralRiverActorTag
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class FName                       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class FName AProceduralRivers::GetProceduralRiverActorTag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ProceduralRivers", "GetProceduralRiverActorTag");

	Params::ProceduralRivers_GetProceduralRiverActorTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRivers.GetVelocityScalarAtDistanceAlongSpline
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UWaterSplineComponent*            WaterSplineComponent                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   DistanceAlongSpline                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AProceduralRivers::GetVelocityScalarAtDistanceAlongSpline(class UWaterSplineComponent* WaterSplineComponent, float DistanceAlongSpline)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ProceduralRivers", "GetVelocityScalarAtDistanceAlongSpline");

	Params::ProceduralRivers_GetVelocityScalarAtDistanceAlongSpline Parms{};

	Parms.WaterSplineComponent = WaterSplineComponent;
	Parms.DistanceAlongSpline = DistanceAlongSpline;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRivers.GetRiverMergeSearchNeighborGridSize
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AProceduralRivers::GetRiverMergeSearchNeighborGridSize()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralRivers", "GetRiverMergeSearchNeighborGridSize");

	Params::ProceduralRivers_GetRiverMergeSearchNeighborGridSize Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRivers.HaltRiverGeneration
// (Final, Native, Public, BlueprintCallable)

void AProceduralRivers::HaltRiverGeneration()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralRivers", "HaltRiverGeneration");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.ProceduralRivers.InitializeNeighborGrid
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AProceduralRivers::InitializeNeighborGrid()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralRivers", "InitializeNeighborGrid");

	Params::ProceduralRivers_InitializeNeighborGrid Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRivers.RebuildLastRiver
// (Final, Native, Public, BlueprintCallable)

void AProceduralRivers::RebuildLastRiver()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralRivers", "RebuildLastRiver");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.ProceduralRivers.SetRiverTier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELandmassRiverTier                      InRiverTier                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AProceduralRivers::SetRiverTier(ELandmassRiverTier InRiverTier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralRivers", "SetRiverTier");

	Params::ProceduralRivers_SetRiverTier Parms{};

	Parms.InRiverTier = InRiverTier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.ProceduralRivers.StartRiverGeneration
// (Final, Native, Public, BlueprintCallable)

void AProceduralRivers::StartRiverGeneration()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralRivers", "StartRiverGeneration");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.ProceduralRivers.SurfaceLocationOverride
// (Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   InLocation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool*                                   bOutIsOverriden                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector AProceduralRivers::SurfaceLocationOverride(const struct FVector& InLocation, bool* bOutIsOverriden)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralRivers", "SurfaceLocationOverride");

	Params::ProceduralRivers_SurfaceLocationOverride Parms{};

	Parms.InLocation = std::move(InLocation);

	UObject::ProcessEvent(Func, &Parms);

	if (bOutIsOverriden != nullptr)
		*bOutIsOverriden = Parms.bOutIsOverriden;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRivers.VisualizeAnchors
// (Final, Native, Public, BlueprintCallable)

void AProceduralRivers::VisualizeAnchors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralRivers", "VisualizeAnchors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.ProceduralRivers.GetAvailableSourceAnchors
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FProceduralRiverAnchor>   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FProceduralRiverAnchor> AProceduralRivers::GetAvailableSourceAnchors() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralRivers", "GetAvailableSourceAnchors");

	Params::ProceduralRivers_GetAvailableSourceAnchors Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRivers.GetAvailableTargetAnchors
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FProceduralRiverAnchor>   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FProceduralRiverAnchor> AProceduralRivers::GetAvailableTargetAnchors() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralRivers", "GetAvailableTargetAnchors");

	Params::ProceduralRivers_GetAvailableTargetAnchors Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRivers.GetGenerationRules
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const ELandmassRiverTier                InRiverTier                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FProceduralRiverGenRules*        OutRules                                               (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AProceduralRivers::GetGenerationRules(const ELandmassRiverTier InRiverTier, struct FProceduralRiverGenRules* OutRules) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralRivers", "GetGenerationRules");

	Params::ProceduralRivers_GetGenerationRules Parms{};

	Parms.InRiverTier = InRiverTier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutRules != nullptr)
		*OutRules = std::move(Parms.OutRules);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRivers.GetRiverDefinitions
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UProceduralRiverDefinition*>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UProceduralRiverDefinition*> AProceduralRivers::GetRiverDefinitions() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralRivers", "GetRiverDefinitions");

	Params::ProceduralRivers_GetRiverDefinitions Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRoads.EvaluateRouteAtLength
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UProceduralRoadDefinition*  InRoute                                                (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InLength                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTransformToWorld                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSegmentInterpResult             ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FSegmentInterpResult AProceduralRoads::EvaluateRouteAtLength(const class UProceduralRoadDefinition* InRoute, float InLength, bool bTransformToWorld)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ProceduralRoads", "EvaluateRouteAtLength");

	Params::ProceduralRoads_EvaluateRouteAtLength Parms{};

	Parms.InRoute = InRoute;
	Parms.InLength = InLength;
	Parms.bTransformToWorld = bTransformToWorld;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRoads.GetProceduralRoadActorTag
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName AProceduralRoads::GetProceduralRoadActorTag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ProceduralRoads", "GetProceduralRoadActorTag");

	Params::ProceduralRoads_GetProceduralRoadActorTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRoads.GetProceduralRoadLoopAnchorTag
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   LoopIndex                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName AProceduralRoads::GetProceduralRoadLoopAnchorTag(int32 LoopIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ProceduralRoads", "GetProceduralRoadLoopAnchorTag");

	Params::ProceduralRoads_GetProceduralRoadLoopAnchorTag Parms{};

	Parms.LoopIndex = LoopIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRoads.DisableOverrideGenRules
// (Final, Native, Public, BlueprintCallable)

void AProceduralRoads::DisableOverrideGenRules()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralRoads", "DisableOverrideGenRules");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.ProceduralRoads.EnableOverrideGenRules
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// const struct FProceduralRoadGenRules&   InOverrideGenRules                                     (Parm, NativeAccessSpecifierPublic)

void AProceduralRoads::EnableOverrideGenRules(const struct FProceduralRoadGenRules& InOverrideGenRules)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralRoads", "EnableOverrideGenRules");

	Params::ProceduralRoads_EnableOverrideGenRules Parms{};

	Parms.InOverrideGenRules = std::move(InOverrideGenRules);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.ProceduralRoads.GetAllControlPoints
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class ULandscapeSplineControlPoint*>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ULandscapeSplineControlPoint*> AProceduralRoads::GetAllControlPoints()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralRoads", "GetAllControlPoints");

	Params::ProceduralRoads_GetAllControlPoints Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRoads.InitializeNeighborGrid
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AProceduralRoads::InitializeNeighborGrid()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralRoads", "InitializeNeighborGrid");

	Params::ProceduralRoads_InitializeNeighborGrid Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRoads.K2_GetRoadGridDataAtLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// const struct FVector&                   InLocation                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FVector>                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FVector> AProceduralRoads::K2_GetRoadGridDataAtLocation(const struct FVector& InLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralRoads", "K2_GetRoadGridDataAtLocation");

	Params::ProceduralRoads_K2_GetRoadGridDataAtLocation Parms{};

	Parms.InLocation = std::move(InLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRoads.RemoveHardTurnControlPoint
// (Final, Native, Protected, BlueprintCallable)

void AProceduralRoads::RemoveHardTurnControlPoint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralRoads", "RemoveHardTurnControlPoint");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.ProceduralRoads.SetRoadTier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ELandmassRoadTier                       InRoadTier                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AProceduralRoads::SetRoadTier(ELandmassRoadTier InRoadTier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralRoads", "SetRoadTier");

	Params::ProceduralRoads_SetRoadTier Parms{};

	Parms.InRoadTier = InRoadTier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.ProceduralRoads.UpdateLandscapeSplines
// (Final, Native, Protected, BlueprintCallable)

void AProceduralRoads::UpdateLandscapeSplines()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralRoads", "UpdateLandscapeSplines");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JunoProceduralWorld.ProceduralRoads.GetGenerationRules
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const ELandmassRoadTier                 InRoadTier                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FProceduralRoadGenRules*         OutRules                                               (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AProceduralRoads::GetGenerationRules(const ELandmassRoadTier InRoadTier, struct FProceduralRoadGenRules* OutRules) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralRoads", "GetGenerationRules");

	Params::ProceduralRoads_GetGenerationRules Parms{};

	Parms.InRoadTier = InRoadTier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutRules != nullptr)
		*OutRules = std::move(Parms.OutRules);

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRoads.GetRoadDefinitions
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UProceduralRoadDefinition*>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UProceduralRoadDefinition*> AProceduralRoads::GetRoadDefinitions() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralRoads", "GetRoadDefinitions");

	Params::ProceduralRoads_GetRoadDefinitions Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JunoProceduralWorld.ProceduralRoads.GetRoadMergeSearchNeighborGridSize
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float AProceduralRoads::GetRoadMergeSearchNeighborGridSize() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ProceduralRoads", "GetRoadMergeSearchNeighborGridSize");

	Params::ProceduralRoads_GetRoadMergeSearchNeighborGridSize Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}

}

