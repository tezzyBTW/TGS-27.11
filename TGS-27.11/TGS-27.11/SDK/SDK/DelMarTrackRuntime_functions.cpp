#pragma once

/*
* SDK generated by Dumper-8
*
* https://github.com/NotTacs/Dumper-8
*/

// Package: DelMarTrackRuntime

#include "Basic.hpp"

#include "DelMarTrackRuntime_classes.hpp"
#include "DelMarTrackRuntime_parameters.hpp"


namespace SDK
{

// Function DelMarTrackRuntime.DelMarTrackBase.ConvertTrackTagsToV2
// (Final, Native, Public)

void ADelMarTrackBase::ConvertTrackTagsToV2()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackBase", "ConvertTrackTagsToV2");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarTrackRuntime.DelMarTrackBase.GetAllTrackSegmentActors
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class ADelMarTrackSegmentBase*>  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class ADelMarTrackSegmentBase*> ADelMarTrackBase::GetAllTrackSegmentActors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackBase", "GetAllTrackSegmentActors");

	Params::DelMarTrackBase_GetAllTrackSegmentActors Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackBase.InitializeSpline
// (Event, Protected, BlueprintEvent)

void ADelMarTrackBase::InitializeSpline()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackBase", "InitializeSpline");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DelMarTrackRuntime.DelMarTrackBase.OnMetadataChanged
// (Final, Native, Protected)
// Parameters:
// class UDelMarTrackSplineComponent*      InSpline                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SplineIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarTrackBase::OnMetadataChanged(class UDelMarTrackSplineComponent* InSpline, int32 SplineIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackBase", "OnMetadataChanged");

	Params::DelMarTrackBase_OnMetadataChanged Parms{};

	Parms.InSpline = InSpline;
	Parms.SplineIndex = SplineIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarTrackRuntime.DelMarTrackBase.OnSplineClosedLoopChanged
// (Final, Native, Protected)
// Parameters:
// class UDelMarTrackSplineComponent*      InSpline                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SplineIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarTrackBase::OnSplineClosedLoopChanged(class UDelMarTrackSplineComponent* InSpline, int32 SplineIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackBase", "OnSplineClosedLoopChanged");

	Params::DelMarTrackBase_OnSplineClosedLoopChanged Parms{};

	Parms.InSpline = InSpline;
	Parms.SplineIndex = SplineIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarTrackRuntime.DelMarTrackBase.OnSplinePointAdded
// (Final, Native, Protected)
// Parameters:
// class UDelMarTrackSplineComponent*      InSpline                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SplineIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarTrackBase::OnSplinePointAdded(class UDelMarTrackSplineComponent* InSpline, int32 SplineIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackBase", "OnSplinePointAdded");

	Params::DelMarTrackBase_OnSplinePointAdded Parms{};

	Parms.InSpline = InSpline;
	Parms.SplineIndex = SplineIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarTrackRuntime.DelMarTrackBase.OnSplinePointChanged
// (Final, Native, Protected)
// Parameters:
// class UDelMarTrackSplineComponent*      InSpline                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SplineIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarTrackBase::OnSplinePointChanged(class UDelMarTrackSplineComponent* InSpline, int32 SplineIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackBase", "OnSplinePointChanged");

	Params::DelMarTrackBase_OnSplinePointChanged Parms{};

	Parms.InSpline = InSpline;
	Parms.SplineIndex = SplineIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarTrackRuntime.DelMarTrackBase.OnSplinePointRemoved
// (Final, Native, Protected)
// Parameters:
// class UDelMarTrackSplineComponent*      InSpline                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SplineIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarTrackBase::OnSplinePointRemoved(class UDelMarTrackSplineComponent* InSpline, int32 SplineIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackBase", "OnSplinePointRemoved");

	Params::DelMarTrackBase_OnSplinePointRemoved Parms{};

	Parms.InSpline = InSpline;
	Parms.SplineIndex = SplineIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarTrackRuntime.DelMarTrackBase.PostSplineSegmentGenerated
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UDelMarTrackSplineComponent*      SplineComp                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PointIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarTrackBase::PostSplineSegmentGenerated(class UDelMarTrackSplineComponent* SplineComp, int32 PointIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackBase", "PostSplineSegmentGenerated");

	Params::DelMarTrackBase_PostSplineSegmentGenerated Parms{};

	Parms.SplineComp = SplineComp;
	Parms.PointIndex = PointIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DelMarTrackRuntime.DelMarTrackBase.PreSplineSegmentGenerated
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UDelMarTrackSplineComponent*      SplineComp                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PointIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarTrackBase::PreSplineSegmentGenerated(class UDelMarTrackSplineComponent* SplineComp, int32 PointIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackBase", "PreSplineSegmentGenerated");

	Params::DelMarTrackBase_PreSplineSegmentGenerated Parms{};

	Parms.SplineComp = SplineComp;
	Parms.PointIndex = PointIndex;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DelMarTrackRuntime.DelMarTrackBase.RebuildTrack
// (Final, Native, Public)

void ADelMarTrackBase::RebuildTrack()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackBase", "RebuildTrack");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function DelMarTrackRuntime.DelMarTrackBase.SetTrackTypeTagAtIndex
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// int32                                   SplineIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag&              tag                                                    (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarTrackBase::SetTrackTypeTagAtIndex(int32 SplineIndex, const struct FGameplayTag& tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackBase", "SetTrackTypeTagAtIndex");

	Params::DelMarTrackBase_SetTrackTypeTagAtIndex Parms{};

	Parms.SplineIndex = SplineIndex;
	Parms.tag = std::move(tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarTrackRuntime.DelMarTrackBase.GetDistanceRangeFromPointRange
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FDelMarTrackPointIndexRange&InRange                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FDelMarTrackPointDistanceRange   ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FDelMarTrackPointDistanceRange ADelMarTrackBase::GetDistanceRangeFromPointRange(const struct FDelMarTrackPointIndexRange& InRange) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackBase", "GetDistanceRangeFromPointRange");

	Params::DelMarTrackBase_GetDistanceRangeFromPointRange Parms{};

	Parms.InRange = std::move(InRange);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackBase.GetEndCapClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   SplineIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UClass* ADelMarTrackBase::GetEndCapClass(int32 SplineIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackBase", "GetEndCapClass");

	Params::DelMarTrackBase_GetEndCapClass Parms{};

	Parms.SplineIndex = SplineIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackBase.GetForwardDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   Start                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADelMarTrackBase::GetForwardDistance(float Start, float End) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackBase", "GetForwardDistance");

	Params::DelMarTrackBase_GetForwardDistance Parms{};

	Parms.Start = Start;
	Parms.End = End;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackBase.GetLoopDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   InTotalDistance                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADelMarTrackBase::GetLoopDistance(float InTotalDistance) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackBase", "GetLoopDistance");

	Params::DelMarTrackBase_GetLoopDistance Parms{};

	Parms.InTotalDistance = InTotalDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackBase.GetMetaDataAtSplinePoint
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   SplineIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FDelMarSplinePointMetaData ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FDelMarSplinePointMetaData ADelMarTrackBase::GetMetaDataAtSplinePoint(int32 SplineIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackBase", "GetMetaDataAtSplinePoint");

	Params::DelMarTrackBase_GetMetaDataAtSplinePoint Parms{};

	Parms.SplineIndex = SplineIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackBase.GetNextSplinePoint
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   InSplinePoint                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ADelMarTrackBase::GetNextSplinePoint(int32 InSplinePoint) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackBase", "GetNextSplinePoint");

	Params::DelMarTrackBase_GetNextSplinePoint Parms{};

	Parms.InSplinePoint = InSplinePoint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackBase.GetNextSplineSegment
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   InSplineSegmentIndex                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ADelMarTrackBase::GetNextSplineSegment(int32 InSplineSegmentIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackBase", "GetNextSplineSegment");

	Params::DelMarTrackBase_GetNextSplineSegment Parms{};

	Parms.InSplineSegmentIndex = InSplineSegmentIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackBase.GetPreviousSplinePoint
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   InSplinePoint                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ADelMarTrackBase::GetPreviousSplinePoint(int32 InSplinePoint) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackBase", "GetPreviousSplinePoint");

	Params::DelMarTrackBase_GetPreviousSplinePoint Parms{};

	Parms.InSplinePoint = InSplinePoint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackBase.GetPreviousSplineSegment
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   InSplineSegmentIndex                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ADelMarTrackBase::GetPreviousSplineSegment(int32 InSplineSegmentIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackBase", "GetPreviousSplineSegment");

	Params::DelMarTrackBase_GetPreviousSplineSegment Parms{};

	Parms.InSplineSegmentIndex = InSplineSegmentIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackBase.GetSegmentClassAtSplinePoint
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   SplineIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UClass* ADelMarTrackBase::GetSegmentClassAtSplinePoint(int32 SplineIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackBase", "GetSegmentClassAtSplinePoint");

	Params::DelMarTrackBase_GetSegmentClassAtSplinePoint Parms{};

	Parms.SplineIndex = SplineIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackBase.GetSegmentTrackTypeTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   SplineIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag               ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FGameplayTag ADelMarTrackBase::GetSegmentTrackTypeTag(int32 SplineIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackBase", "GetSegmentTrackTypeTag");

	Params::DelMarTrackBase_GetSegmentTrackTypeTag Parms{};

	Parms.SplineIndex = SplineIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackBase.GetStartCapClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   SplineIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UClass* ADelMarTrackBase::GetStartCapClass(int32 SplineIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackBase", "GetStartCapClass");

	Params::DelMarTrackBase_GetStartCapClass Parms{};

	Parms.SplineIndex = SplineIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackBase.GetTransitionSegmentClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   FromSplineIndex                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ToSplineIndex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UClass* ADelMarTrackBase::GetTransitionSegmentClass(int32 FromSplineIndex, int32 ToSplineIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackBase", "GetTransitionSegmentClass");

	Params::DelMarTrackBase_GetTransitionSegmentClass Parms{};

	Parms.FromSplineIndex = FromSplineIndex;
	Parms.ToSplineIndex = ToSplineIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackBase.IsCosmetic
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADelMarTrackBase::IsCosmetic() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackBase", "IsCosmetic");

	Params::DelMarTrackBase_IsCosmetic Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackBase.IsDistanceWithinRange
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   InDistance                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartDistance                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EndDistance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADelMarTrackBase::IsDistanceWithinRange(float InDistance, float StartDistance, float EndDistance) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackBase", "IsDistanceWithinRange");

	Params::DelMarTrackBase_IsDistanceWithinRange Parms{};

	Parms.InDistance = InDistance;
	Parms.StartDistance = StartDistance;
	Parms.EndDistance = EndDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackBase.IsPointInOOBTube
// (Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const struct FVector&                   Point                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADelMarTrackBase::IsPointInOOBTube(const struct FVector& Point) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackBase", "IsPointInOOBTube");

	Params::DelMarTrackBase_IsPointInOOBTube Parms{};

	Parms.Point = std::move(Point);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackBase.IsPrimary
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADelMarTrackBase::IsPrimary() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackBase", "IsPrimary");

	Params::DelMarTrackBase_IsPrimary Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackBase.IsSecondary
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADelMarTrackBase::IsSecondary() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackBase", "IsSecondary");

	Params::DelMarTrackBase_IsSecondary Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackBase.IsTrackable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADelMarTrackBase::IsTrackable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackBase", "IsTrackable");

	Params::DelMarTrackBase_IsTrackable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrack.MergeTrack
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADelMarTrack*                     OtherTrack                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    MergeToEndPoint                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    CopyFromStartPoint                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADelMarTrack::MergeTrack(class ADelMarTrack* OtherTrack, bool MergeToEndPoint, bool CopyFromStartPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrack", "MergeTrack");

	Params::DelMarTrack_MergeTrack Parms{};

	Parms.OtherTrack = OtherTrack;
	Parms.MergeToEndPoint = MergeToEndPoint;
	Parms.CopyFromStartPoint = CopyFromStartPoint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrack.SplitTrackAtPoint
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   SplitAtPoint                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADelMarTrack::SplitTrackAtPoint(int32 SplitAtPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrack", "SplitTrackAtPoint");

	Params::DelMarTrack_SplitTrackAtPoint Parms{};

	Parms.SplitAtPoint = SplitAtPoint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrack.GetParentEndDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADelMarTrack::GetParentEndDistance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrack", "GetParentEndDistance");

	Params::DelMarTrack_GetParentEndDistance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrack.GetParentStartDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADelMarTrack::GetParentStartDistance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrack", "GetParentStartDistance");

	Params::DelMarTrack_GetParentStartDistance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrack.GetPrimaryDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   DistanceOnThisTrack                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADelMarTrack::GetPrimaryDistance(float DistanceOnThisTrack) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrack", "GetPrimaryDistance");

	Params::DelMarTrack_GetPrimaryDistance Parms{};

	Parms.DistanceOnThisTrack = DistanceOnThisTrack;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrack.GetPrimaryEndDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADelMarTrack::GetPrimaryEndDistance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrack", "GetPrimaryEndDistance");

	Params::DelMarTrack_GetPrimaryEndDistance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrack.GetPrimaryStartDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ADelMarTrack::GetPrimaryStartDistance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrack", "GetPrimaryStartDistance");

	Params::DelMarTrack_GetPrimaryStartDistance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrack.GetSecondaryEndTrack
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADelMarTrack*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADelMarTrack* ADelMarTrack::GetSecondaryEndTrack() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrack", "GetSecondaryEndTrack");

	Params::DelMarTrack_GetSecondaryEndTrack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrack.GetSecondaryStartTrack
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADelMarTrack*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADelMarTrack* ADelMarTrack::GetSecondaryStartTrack() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrack", "GetSecondaryStartTrack");

	Params::DelMarTrack_GetSecondaryStartTrack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackBlueprintFunctionLibrary.IsTrackRadiusCheckDisabled
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDelMarTrackBlueprintFunctionLibrary::IsTrackRadiusCheckDisabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DelMarTrackBlueprintFunctionLibrary", "IsTrackRadiusCheckDisabled");

	Params::DelMarTrackBlueprintFunctionLibrary_IsTrackRadiusCheckDisabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackBlueprintFunctionLibrary.TrackPositionDebugDrawEnabled
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDelMarTrackBlueprintFunctionLibrary::TrackPositionDebugDrawEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DelMarTrackBlueprintFunctionLibrary", "TrackPositionDebugDrawEnabled");

	Params::DelMarTrackBlueprintFunctionLibrary_TrackPositionDebugDrawEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackSegmentBase.ContainsDistanceAlongSpline
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const float                             DistanceAlongSpline                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADelMarTrackSegmentBase::ContainsDistanceAlongSpline(const float DistanceAlongSpline) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackSegmentBase", "ContainsDistanceAlongSpline");

	Params::DelMarTrackSegmentBase_ContainsDistanceAlongSpline Parms{};

	Parms.DistanceAlongSpline = DistanceAlongSpline;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackSegmentBase.GetSplineDistanceRange
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FDelMarTrackPointDistanceRange   ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FDelMarTrackPointDistanceRange ADelMarTrackSegmentBase::GetSplineDistanceRange() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackSegmentBase", "GetSplineDistanceRange");

	Params::DelMarTrackSegmentBase_GetSplineDistanceRange Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackSegmentBase.GetSplineMeshComponent
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class USplineMeshComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USplineMeshComponent* ADelMarTrackSegmentBase::GetSplineMeshComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackSegmentBase", "GetSplineMeshComponent");

	Params::DelMarTrackSegmentBase_GetSplineMeshComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackOobTube.OnAttachedTrackPointAdded
// (Final, Native, Private)
// Parameters:
// class UDelMarTrackSplineComponent*      InSpline                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PointIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarTrackOobTube::OnAttachedTrackPointAdded(class UDelMarTrackSplineComponent* InSpline, int32 PointIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackOobTube", "OnAttachedTrackPointAdded");

	Params::DelMarTrackOobTube_OnAttachedTrackPointAdded Parms{};

	Parms.InSpline = InSpline;
	Parms.PointIndex = PointIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarTrackRuntime.DelMarTrackOobTube.OnAttachedTrackPointChanged
// (Final, Native, Private)
// Parameters:
// class UDelMarTrackSplineComponent*      InSpline                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PointIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarTrackOobTube::OnAttachedTrackPointChanged(class UDelMarTrackSplineComponent* InSpline, int32 PointIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackOobTube", "OnAttachedTrackPointChanged");

	Params::DelMarTrackOobTube_OnAttachedTrackPointChanged Parms{};

	Parms.InSpline = InSpline;
	Parms.PointIndex = PointIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarTrackRuntime.DelMarTrackOobTube.OnAttachedTrackPointRemoved
// (Final, Native, Private)
// Parameters:
// class UDelMarTrackSplineComponent*      InSpline                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PointIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarTrackOobTube::OnAttachedTrackPointRemoved(class UDelMarTrackSplineComponent* InSpline, int32 PointIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackOobTube", "OnAttachedTrackPointRemoved");

	Params::DelMarTrackOobTube_OnAttachedTrackPointRemoved Parms{};

	Parms.InSpline = InSpline;
	Parms.PointIndex = PointIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarTrackRuntime.DelMarTrackOobTube.OnConstructTubeMesh
// (Event, Protected, BlueprintEvent)
// Parameters:
// class USplineMeshComponent*             TubeMeshComponent                                      (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsTransitionMesh                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsTransitionIn                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ADelMarTrackOobTube::OnConstructTubeMesh(class USplineMeshComponent* TubeMeshComponent, bool bIsTransitionMesh, bool bIsTransitionIn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackOobTube", "OnConstructTubeMesh");

	Params::DelMarTrackOobTube_OnConstructTubeMesh Parms{};

	Parms.TubeMeshComponent = TubeMeshComponent;
	Parms.bIsTransitionMesh = bIsTransitionMesh;
	Parms.bIsTransitionIn = bIsTransitionIn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function DelMarTrackRuntime.DelMarTrackOobTube.OnPostContructedOOBTube
// (Event, Protected, BlueprintEvent)

void ADelMarTrackOobTube::OnPostContructedOOBTube()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackOobTube", "OnPostContructedOOBTube");

	UObject::ProcessEvent(Func, nullptr);
}


// Function DelMarTrackRuntime.DelMarTrackOobTube.DetermineTubeMeshTransitionType
// (Native, Event, Protected, BlueprintEvent, Const)
// Parameters:
// int32                                   CurrentPointIndex                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NextPointIndex                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDelMarTrackOobTubeTransitionType       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDelMarTrackOobTubeTransitionType ADelMarTrackOobTube::DetermineTubeMeshTransitionType(int32 CurrentPointIndex, int32 NextPointIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackOobTube", "DetermineTubeMeshTransitionType");

	Params::DelMarTrackOobTube_DetermineTubeMeshTransitionType Parms{};

	Parms.CurrentPointIndex = CurrentPointIndex;
	Parms.NextPointIndex = NextPointIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackOobTube.GetSplinePointTagAtIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   PointIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FGameplayTag               ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const struct FGameplayTag ADelMarTrackOobTube::GetSplinePointTagAtIndex(int32 PointIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackOobTube", "GetSplinePointTagAtIndex");

	Params::DelMarTrackOobTube_GetSplinePointTagAtIndex Parms{};

	Parms.PointIndex = PointIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackOobTube.IsAttachedToPrimaryTrack
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADelMarTrackOobTube::IsAttachedToPrimaryTrack() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackOobTube", "IsAttachedToPrimaryTrack");

	Params::DelMarTrackOobTube_IsAttachedToPrimaryTrack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackOobTube.IsAttachedToSecondaryTrack
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADelMarTrackOobTube::IsAttachedToSecondaryTrack() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackOobTube", "IsAttachedToSecondaryTrack");

	Params::DelMarTrackOobTube_IsAttachedToSecondaryTrack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackOobTube.IsSplinePointOffset
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   PointIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ADelMarTrackOobTube::IsSplinePointOffset(int32 PointIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackOobTube", "IsSplinePointOffset");

	Params::DelMarTrackOobTube_IsSplinePointOffset Parms{};

	Parms.PointIndex = PointIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackSplineComponent.FindClosestLocationForSegmentToWorldPlane
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector&                   WorldPlaneOrigin                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   WorldPlaneNormal                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             SegmentIndex                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UDelMarTrackSplineComponent::FindClosestLocationForSegmentToWorldPlane(const struct FVector& WorldPlaneOrigin, const struct FVector& WorldPlaneNormal, const int32 SegmentIndex, ESplineCoordinateSpace CoordinateSpace) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackSplineComponent", "FindClosestLocationForSegmentToWorldPlane");

	Params::DelMarTrackSplineComponent_FindClosestLocationForSegmentToWorldPlane Parms{};

	Parms.WorldPlaneOrigin = std::move(WorldPlaneOrigin);
	Parms.WorldPlaneNormal = std::move(WorldPlaneNormal);
	Parms.SegmentIndex = SegmentIndex;
	Parms.CoordinateSpace = CoordinateSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackSplineComponent.FindClosestLocationToWorldPlane
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector&                   WorldPlaneOrigin                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   WorldPlaneNormal                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UDelMarTrackSplineComponent::FindClosestLocationToWorldPlane(const struct FVector& WorldPlaneOrigin, const struct FVector& WorldPlaneNormal, ESplineCoordinateSpace CoordinateSpace) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackSplineComponent", "FindClosestLocationToWorldPlane");

	Params::DelMarTrackSplineComponent_FindClosestLocationToWorldPlane Parms{};

	Parms.WorldPlaneOrigin = std::move(WorldPlaneOrigin);
	Parms.WorldPlaneNormal = std::move(WorldPlaneNormal);
	Parms.CoordinateSpace = CoordinateSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackSplineComponent.FindInputKeyClosestToWorldPlane
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector&                   WorldPlaneOrigin                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   WorldPlaneNormal                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDelMarTrackSplineComponent::FindInputKeyClosestToWorldPlane(const struct FVector& WorldPlaneOrigin, const struct FVector& WorldPlaneNormal) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackSplineComponent", "FindInputKeyClosestToWorldPlane");

	Params::DelMarTrackSplineComponent_FindInputKeyClosestToWorldPlane Parms{};

	Parms.WorldPlaneOrigin = std::move(WorldPlaneOrigin);
	Parms.WorldPlaneNormal = std::move(WorldPlaneNormal);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackSplineComponent.FindInputKeyForNeighboringSegmentClosestToWorldPlane
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector&                   WorldPlaneOrigin                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   WorldPlaneNormal                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             SegmentIndex                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32*                                  OutClosestSegmentIndex                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDelMarTrackSplineComponent::FindInputKeyForNeighboringSegmentClosestToWorldPlane(const struct FVector& WorldPlaneOrigin, const struct FVector& WorldPlaneNormal, const int32 SegmentIndex, int32* OutClosestSegmentIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackSplineComponent", "FindInputKeyForNeighboringSegmentClosestToWorldPlane");

	Params::DelMarTrackSplineComponent_FindInputKeyForNeighboringSegmentClosestToWorldPlane Parms{};

	Parms.WorldPlaneOrigin = std::move(WorldPlaneOrigin);
	Parms.WorldPlaneNormal = std::move(WorldPlaneNormal);
	Parms.SegmentIndex = SegmentIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutClosestSegmentIndex != nullptr)
		*OutClosestSegmentIndex = Parms.OutClosestSegmentIndex;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackSplineComponent.FindInputKeyForSegmentClosestToWorldPlane
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector&                   WorldPlaneOrigin                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FVector&                   WorldPlaneNormal                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const int32                             SegmentIndex                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDelMarTrackSplineComponent::FindInputKeyForSegmentClosestToWorldPlane(const struct FVector& WorldPlaneOrigin, const struct FVector& WorldPlaneNormal, const int32 SegmentIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackSplineComponent", "FindInputKeyForSegmentClosestToWorldPlane");

	Params::DelMarTrackSplineComponent_FindInputKeyForSegmentClosestToWorldPlane Parms{};

	Parms.WorldPlaneOrigin = std::move(WorldPlaneOrigin);
	Parms.WorldPlaneNormal = std::move(WorldPlaneNormal);
	Parms.SegmentIndex = SegmentIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackSplineComponent.GetForwardDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   Start                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDelMarTrackSplineComponent::GetForwardDistance(float Start, float End) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackSplineComponent", "GetForwardDistance");

	Params::DelMarTrackSplineComponent_GetForwardDistance Parms{};

	Parms.Start = Start;
	Parms.End = End;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackSplineComponent.GetLoopDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   InTotalDistance                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDelMarTrackSplineComponent::GetLoopDistance(float InTotalDistance) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackSplineComponent", "GetLoopDistance");

	Params::DelMarTrackSplineComponent_GetLoopDistance Parms{};

	Parms.InTotalDistance = InTotalDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackSplineComponent.GetNextSplinePoint
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   InSplinePoint                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDelMarTrackSplineComponent::GetNextSplinePoint(int32 InSplinePoint) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackSplineComponent", "GetNextSplinePoint");

	Params::DelMarTrackSplineComponent_GetNextSplinePoint Parms{};

	Parms.InSplinePoint = InSplinePoint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackSplineComponent.GetNextSplineSegment
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   InSplineSegmentIndex                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDelMarTrackSplineComponent::GetNextSplineSegment(int32 InSplineSegmentIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackSplineComponent", "GetNextSplineSegment");

	Params::DelMarTrackSplineComponent_GetNextSplineSegment Parms{};

	Parms.InSplineSegmentIndex = InSplineSegmentIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackSplineComponent.GetPreviousSplinePoint
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   InSplinePoint                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDelMarTrackSplineComponent::GetPreviousSplinePoint(int32 InSplinePoint) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackSplineComponent", "GetPreviousSplinePoint");

	Params::DelMarTrackSplineComponent_GetPreviousSplinePoint Parms{};

	Parms.InSplinePoint = InSplinePoint;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackSplineComponent.GetPreviousSplineSegment
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   InSplineSegmentIndex                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDelMarTrackSplineComponent::GetPreviousSplineSegment(int32 InSplineSegmentIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackSplineComponent", "GetPreviousSplineSegment");

	Params::DelMarTrackSplineComponent_GetPreviousSplineSegment Parms{};

	Parms.InSplineSegmentIndex = InSplineSegmentIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackSplineComponent.GetRotationalMinimalFrames
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<struct FDelMarRotationalMinimalFrame>ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<struct FDelMarRotationalMinimalFrame> UDelMarTrackSplineComponent::GetRotationalMinimalFrames() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackSplineComponent", "GetRotationalMinimalFrames");

	Params::DelMarTrackSplineComponent_GetRotationalMinimalFrames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackSplineComponent.GetRotationalMinimalUpVectorAtDistanceAlongSpline
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   DistanceAlongSpline                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UDelMarTrackSplineComponent::GetRotationalMinimalUpVectorAtDistanceAlongSpline(float DistanceAlongSpline, ESplineCoordinateSpace CoordinateSpace) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackSplineComponent", "GetRotationalMinimalUpVectorAtDistanceAlongSpline");

	Params::DelMarTrackSplineComponent_GetRotationalMinimalUpVectorAtDistanceAlongSpline Parms{};

	Parms.DistanceAlongSpline = DistanceAlongSpline;
	Parms.CoordinateSpace = CoordinateSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackSplineComponent.GetRotationalMinimalUpVectorAtSplinePoint
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   SplinePoint                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESplineCoordinateSpace                  CoordinateSpace                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UDelMarTrackSplineComponent::GetRotationalMinimalUpVectorAtSplinePoint(int32 SplinePoint, ESplineCoordinateSpace CoordinateSpace) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackSplineComponent", "GetRotationalMinimalUpVectorAtSplinePoint");

	Params::DelMarTrackSplineComponent_GetRotationalMinimalUpVectorAtSplinePoint Parms{};

	Parms.SplinePoint = SplinePoint;
	Parms.CoordinateSpace = CoordinateSpace;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackSplineComponent.GetSplinePointAtDistanceAlongSpline
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   DistanceAlongSpline                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDelMarTrackSplineComponent::GetSplinePointAtDistanceAlongSpline(float DistanceAlongSpline) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackSplineComponent", "GetSplinePointAtDistanceAlongSpline");

	Params::DelMarTrackSplineComponent_GetSplinePointAtDistanceAlongSpline Parms{};

	Parms.DistanceAlongSpline = DistanceAlongSpline;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackSplineComponent.GetSplinePointClosestToDistanceAlongSpline
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   DistanceAlongSpline                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDelMarTrackSplineComponent::GetSplinePointClosestToDistanceAlongSpline(float DistanceAlongSpline) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackSplineComponent", "GetSplinePointClosestToDistanceAlongSpline");

	Params::DelMarTrackSplineComponent_GetSplinePointClosestToDistanceAlongSpline Parms{};

	Parms.DistanceAlongSpline = DistanceAlongSpline;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackSplineComponent.GetSplinePointClosestToWorldLocation
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FVector&                   WorldLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDelMarTrackSplineComponent::GetSplinePointClosestToWorldLocation(const struct FVector& WorldLocation) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackSplineComponent", "GetSplinePointClosestToWorldLocation");

	Params::DelMarTrackSplineComponent_GetSplinePointClosestToWorldLocation Parms{};

	Parms.WorldLocation = std::move(WorldLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackSplineComponent.IsDistanceWithinRange
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   InDistance                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StartDistance                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EndDistance                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDelMarTrackSplineComponent::IsDistanceWithinRange(float InDistance, float StartDistance, float EndDistance) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackSplineComponent", "IsDistanceWithinRange");

	Params::DelMarTrackSplineComponent_IsDistanceWithinRange Parms{};

	Parms.InDistance = InDistance;
	Parms.StartDistance = StartDistance;
	Parms.EndDistance = EndDistance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackOobTubeProxy.GetAttachedTrack
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class ADelMarTrack*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADelMarTrack* UDelMarTrackOobTubeProxy::GetAttachedTrack() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackOobTubeProxy", "GetAttachedTrack");

	Params::DelMarTrackOobTubeProxy_GetAttachedTrack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackOobTubeProxy.GetDefaultSubsectionCount
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDelMarTrackOobTubeProxy::GetDefaultSubsectionCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackOobTubeProxy", "GetDefaultSubsectionCount");

	Params::DelMarTrackOobTubeProxy_GetDefaultSubsectionCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackOobTubeProxy.GetDefaultTransitionMeshLength
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

double UDelMarTrackOobTubeProxy::GetDefaultTransitionMeshLength() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackOobTubeProxy", "GetDefaultTransitionMeshLength");

	Params::DelMarTrackOobTubeProxy_GetDefaultTransitionMeshLength Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackOobTubeProxy.GetMinimumMeshScale
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

double UDelMarTrackOobTubeProxy::GetMinimumMeshScale() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackOobTubeProxy", "GetMinimumMeshScale");

	Params::DelMarTrackOobTubeProxy_GetMinimumMeshScale Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackOobTubeProxy.GetOobTubeActor
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UDelMarTrackOobTubeProxy::GetOobTubeActor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackOobTubeProxy", "GetOobTubeActor");

	Params::DelMarTrackOobTubeProxy_GetOobTubeActor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackOobTubeProxy.GetSmallestSubsectionLength
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

double UDelMarTrackOobTubeProxy::GetSmallestSubsectionLength() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackOobTubeProxy", "GetSmallestSubsectionLength");

	Params::DelMarTrackOobTubeProxy_GetSmallestSubsectionLength Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackOobTubeProxy.GetSplineComponent
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class USplineComponent*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USplineComponent* UDelMarTrackOobTubeProxy::GetSplineComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackOobTubeProxy", "GetSplineComponent");

	Params::DelMarTrackOobTubeProxy_GetSplineComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackOobTubeProxy.GetSplineMetadata
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// int32                                   PointIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDelMarTrackOobTubePointMetaData ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FDelMarTrackOobTubePointMetaData UDelMarTrackOobTubeProxy::GetSplineMetadata(int32 PointIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackOobTubeProxy", "GetSplineMetadata");

	Params::DelMarTrackOobTubeProxy_GetSplineMetadata Parms{};

	Parms.PointIndex = PointIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackOobTubeProxy.GetSplineVisualizationOffset
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

double UDelMarTrackOobTubeProxy::GetSplineVisualizationOffset() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackOobTubeProxy", "GetSplineVisualizationOffset");

	Params::DelMarTrackOobTubeProxy_GetSplineVisualizationOffset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackOobTubeCollectionProxy.GetOobTubeProxy
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// int32                                   OobTubeIndex                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UDelMarTrackOobTubeProxy*         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDelMarTrackOobTubeProxy* UDelMarTrackOobTubeCollectionProxy::GetOobTubeProxy(int32 OobTubeIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackOobTubeCollectionProxy", "GetOobTubeProxy");

	Params::DelMarTrackOobTubeCollectionProxy_GetOobTubeProxy Parms{};

	Parms.OobTubeIndex = OobTubeIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackOobTubeCollectionProxy.RegisterOobTube
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           OobTubeActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarTrackOobTubeCollectionProxy::RegisterOobTube(class AActor* OobTubeActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackOobTubeCollectionProxy", "RegisterOobTube");

	Params::DelMarTrackOobTubeCollectionProxy_RegisterOobTube Parms{};

	Parms.OobTubeActor = OobTubeActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarTrackRuntime.DelMarTrackOobTubeCollectionProxy.GetNumOobTubeProxies
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDelMarTrackOobTubeCollectionProxy::GetNumOobTubeProxies() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackOobTubeCollectionProxy", "GetNumOobTubeProxies");

	Params::DelMarTrackOobTubeCollectionProxy_GetNumOobTubeProxies Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackPaletteTrackType.AddSegmentClassActorToStyle
// (Final, Native, Private, HasOutParams, BlueprintCallable)
// Parameters:
// const struct FGameplayTag&              StyleTag                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UClass*                           SegmentClass                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarTrackPaletteTrackType::AddSegmentClassActorToStyle(const struct FGameplayTag& StyleTag, class UClass* SegmentClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackPaletteTrackType", "AddSegmentClassActorToStyle");

	Params::DelMarTrackPaletteTrackType_AddSegmentClassActorToStyle Parms{};

	Parms.StyleTag = std::move(StyleTag);
	Parms.SegmentClass = SegmentClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarTrackRuntime.DelMarTrackPositionComponent.SetActiveTrack
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class ADelMarTrackBase*                 Track                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TrackSegmentIndex                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UDelMarTrackPositionComponent::SetActiveTrack(class ADelMarTrackBase* Track, int32 TrackSegmentIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackPositionComponent", "SetActiveTrack");

	Params::DelMarTrackPositionComponent_SetActiveTrack Parms{};

	Parms.Track = Track;
	Parms.TrackSegmentIndex = TrackSegmentIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function DelMarTrackRuntime.DelMarTrackPositionComponent.GetActiveSegmentIndex
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDelMarTrackPositionComponent::GetActiveSegmentIndex() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackPositionComponent", "GetActiveSegmentIndex");

	Params::DelMarTrackPositionComponent_GetActiveSegmentIndex Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackPositionComponent.GetActiveTrack
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADelMarTrackBase*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADelMarTrackBase* UDelMarTrackPositionComponent::GetActiveTrack() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackPositionComponent", "GetActiveTrack");

	Params::DelMarTrackPositionComponent_GetActiveTrack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackPositionComponent.GetActiveTrackDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDelMarTrackPositionComponent::GetActiveTrackDistance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackPositionComponent", "GetActiveTrackDistance");

	Params::DelMarTrackPositionComponent_GetActiveTrackDistance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackPositionComponent.GetActiveTrackPosition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTrackPosition                   ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FTrackPosition UDelMarTrackPositionComponent::GetActiveTrackPosition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackPositionComponent", "GetActiveTrackPosition");

	Params::DelMarTrackPositionComponent_GetActiveTrackPosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackPositionComponent.GetActiveTrackRadius
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDelMarTrackPositionComponent::GetActiveTrackRadius() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackPositionComponent", "GetActiveTrackRadius");

	Params::DelMarTrackPositionComponent_GetActiveTrackRadius Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackPositionComponent.GetDistanceAlongSpline
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDelMarTrackPositionComponent::GetDistanceAlongSpline() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackPositionComponent", "GetDistanceAlongSpline");

	Params::DelMarTrackPositionComponent_GetDistanceAlongSpline Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackPositionComponent.GetLastKnowGoodSplineLocation
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UDelMarTrackPositionComponent::GetLastKnowGoodSplineLocation() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackPositionComponent", "GetLastKnowGoodSplineLocation");

	Params::DelMarTrackPositionComponent_GetLastKnowGoodSplineLocation Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackPositionComponent.GetPrimaryDistance
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDelMarTrackPositionComponent::GetPrimaryDistance() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackPositionComponent", "GetPrimaryDistance");

	Params::DelMarTrackPositionComponent_GetPrimaryDistance Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackPositionComponent.GetPrimaryTrack
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class ADelMarTrackBase*                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ADelMarTrackBase* UDelMarTrackPositionComponent::GetPrimaryTrack() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackPositionComponent", "GetPrimaryTrack");

	Params::DelMarTrackPositionComponent_GetPrimaryTrack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackPositionComponent.GetPrimaryWorldLocationAlongSpline
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UDelMarTrackPositionComponent::GetPrimaryWorldLocationAlongSpline() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackPositionComponent", "GetPrimaryWorldLocationAlongSpline");

	Params::DelMarTrackPositionComponent_GetPrimaryWorldLocationAlongSpline Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackPositionComponent.GetRawClosestSplineLoction
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UDelMarTrackPositionComponent::GetRawClosestSplineLoction() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackPositionComponent", "GetRawClosestSplineLoction");

	Params::DelMarTrackPositionComponent_GetRawClosestSplineLoction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackPositionComponent.GetWorldDirectionAlongSpline
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UDelMarTrackPositionComponent::GetWorldDirectionAlongSpline() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackPositionComponent", "GetWorldDirectionAlongSpline");

	Params::DelMarTrackPositionComponent_GetWorldDirectionAlongSpline Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackPositionComponent.GetWorldLocationAlongSpline
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UDelMarTrackPositionComponent::GetWorldLocationAlongSpline() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackPositionComponent", "GetWorldLocationAlongSpline");

	Params::DelMarTrackPositionComponent_GetWorldLocationAlongSpline Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackPositionComponent.GetWorldRightVectorAlongSpline
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UDelMarTrackPositionComponent::GetWorldRightVectorAlongSpline() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackPositionComponent", "GetWorldRightVectorAlongSpline");

	Params::DelMarTrackPositionComponent_GetWorldRightVectorAlongSpline Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackPositionComponent.GetWorldTransformAlongSpline
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTransform UDelMarTrackPositionComponent::GetWorldTransformAlongSpline() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackPositionComponent", "GetWorldTransformAlongSpline");

	Params::DelMarTrackPositionComponent_GetWorldTransformAlongSpline Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackPositionComponent.GetWorldUpVectorAlongSpline
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UDelMarTrackPositionComponent::GetWorldUpVectorAlongSpline() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackPositionComponent", "GetWorldUpVectorAlongSpline");

	Params::DelMarTrackPositionComponent_GetWorldUpVectorAlongSpline Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackPositionComponent.HasValidPosition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDelMarTrackPositionComponent::HasValidPosition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackPositionComponent", "HasValidPosition");

	Params::DelMarTrackPositionComponent_HasValidPosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function DelMarTrackRuntime.DelMarTrackPositionComponent.IsOnPrimaryTrack
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDelMarTrackPositionComponent::IsOnPrimaryTrack() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DelMarTrackPositionComponent", "IsOnPrimaryTrack");

	Params::DelMarTrackPositionComponent_IsOnPrimaryTrack Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}

}

