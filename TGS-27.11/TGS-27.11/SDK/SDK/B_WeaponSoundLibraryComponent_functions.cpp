#pragma once

/*
* SDK generated by Dumper-8
*
* https://github.com/NotTacs/Dumper-8
*/

// Package: B_WeaponSoundLibraryComponent

#include "Basic.hpp"

#include "B_WeaponSoundLibraryComponent_classes.hpp"
#include "B_WeaponSoundLibraryComponent_parameters.hpp"


namespace SDK
{

// Function B_WeaponSoundLibraryComponent.B_WeaponSoundLibraryComponent_C.AddConnectedGraphInput
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             InputName                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FName                             DataType                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UMetaSoundSourceBuilder*          BuilderRef                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// const struct FMetaSoundNodeHandle&      BaseWeaponNodeHandleRef                                (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)

void UB_WeaponSoundLibraryComponent_C::AddConnectedGraphInput(class FName InputName, class FName DataType, class UMetaSoundSourceBuilder* BuilderRef, const struct FMetaSoundNodeHandle& BaseWeaponNodeHandleRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_WeaponSoundLibraryComponent_C", "AddConnectedGraphInput");

	Params::B_WeaponSoundLibraryComponent_C_AddConnectedGraphInput Parms{};

	Parms.InputName = InputName;
	Parms.DataType = DataType;
	Parms.BuilderRef = BuilderRef;
	Parms.BaseWeaponNodeHandleRef = std::move(BaseWeaponNodeHandleRef);

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_WeaponSoundLibraryComponent.B_WeaponSoundLibraryComponent_C.CheckIfSuppressor
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UMetaSoundBuilderBase*            BuilderRef                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// const struct FMetaSoundNodeHandle&      BaseNodeHandle                                         (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor)
// const struct FMetaSoundNodeHandle&      ModNodeHandle                                          (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// const class UObject*                    ModRef                                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UB_WeaponSoundLibraryComponent_C::CheckIfSuppressor(class UMetaSoundBuilderBase* BuilderRef, const struct FMetaSoundNodeHandle& BaseNodeHandle, const struct FMetaSoundNodeHandle& ModNodeHandle, const class UObject* ModRef)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_WeaponSoundLibraryComponent_C", "CheckIfSuppressor");

	Params::B_WeaponSoundLibraryComponent_C_CheckIfSuppressor Parms{};

	Parms.BuilderRef = BuilderRef;
	Parms.BaseNodeHandle = std::move(BaseNodeHandle);
	Parms.ModNodeHandle = std::move(ModNodeHandle);
	Parms.ModRef = ModRef;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_WeaponSoundLibraryComponent.B_WeaponSoundLibraryComponent_C.ConnectInterfaceInputs
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UMetaSoundBuilderBase*            BuilderRef                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// const struct FMetaSoundNodeHandle&      BaseWeaponNodeHandle                                   (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor)
// class FName                             InputName                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UB_WeaponSoundLibraryComponent_C::ConnectInterfaceInputs(class UMetaSoundBuilderBase* BuilderRef, const struct FMetaSoundNodeHandle& BaseWeaponNodeHandle, class FName InputName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_WeaponSoundLibraryComponent_C", "ConnectInterfaceInputs");

	Params::B_WeaponSoundLibraryComponent_C_ConnectInterfaceInputs Parms{};

	Parms.BuilderRef = BuilderRef;
	Parms.BaseWeaponNodeHandle = std::move(BaseWeaponNodeHandle);
	Parms.InputName = InputName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_WeaponSoundLibraryComponent.B_WeaponSoundLibraryComponent_C.ConnectNodesIO
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UMetaSoundBuilderBase*            BuilderRef                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class FName                             InputName                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FName                             OutputName                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FMetaSoundNodeHandle&      BaseNodeHandle                                         (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// const struct FMetaSoundNodeHandle&      ModNodeHandle                                          (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)

void UB_WeaponSoundLibraryComponent_C::ConnectNodesIO(class UMetaSoundBuilderBase* BuilderRef, class FName InputName, class FName OutputName, const struct FMetaSoundNodeHandle& BaseNodeHandle, const struct FMetaSoundNodeHandle& ModNodeHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_WeaponSoundLibraryComponent_C", "ConnectNodesIO");

	Params::B_WeaponSoundLibraryComponent_C_ConnectNodesIO Parms{};

	Parms.BuilderRef = BuilderRef;
	Parms.InputName = InputName;
	Parms.OutputName = OutputName;
	Parms.BaseNodeHandle = std::move(BaseNodeHandle);
	Parms.ModNodeHandle = std::move(ModNodeHandle);

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_WeaponSoundLibraryComponent.B_WeaponSoundLibraryComponent_C.CreateModMetaSound
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UB_WeaponSoundLibraryComponent_C::CreateModMetaSound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_WeaponSoundLibraryComponent_C", "CreateModMetaSound");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_WeaponSoundLibraryComponent.B_WeaponSoundLibraryComponent_C.CreateModSoundLibrary
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UB_WeaponSoundLibraryComponent_C::CreateModSoundLibrary()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_WeaponSoundLibraryComponent_C", "CreateModSoundLibrary");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_WeaponSoundLibraryComponent.B_WeaponSoundLibraryComponent_C.ExecuteUbergraph_B_WeaponSoundLibraryComponent
// (Final, UbergraphFunction)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UB_WeaponSoundLibraryComponent_C::ExecuteUbergraph_B_WeaponSoundLibraryComponent(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_WeaponSoundLibraryComponent_C", "ExecuteUbergraph_B_WeaponSoundLibraryComponent");

	Params::B_WeaponSoundLibraryComponent_C_ExecuteUbergraph_B_WeaponSoundLibraryComponent Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_WeaponSoundLibraryComponent.B_WeaponSoundLibraryComponent_C.GetSoundsFromEvent
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              InEventName                                            (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// TArray<class USoundBase*>*              Out_Sounds                                             (Parm, OutParm)

void UB_WeaponSoundLibraryComponent_C::GetSoundsFromEvent(const struct FGameplayTag& InEventName, TArray<class USoundBase*>* Out_Sounds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_WeaponSoundLibraryComponent_C", "GetSoundsFromEvent");

	Params::B_WeaponSoundLibraryComponent_C_GetSoundsFromEvent Parms{};

	Parms.InEventName = std::move(InEventName);

	UObject::ProcessEvent(Func, &Parms);

	if (Out_Sounds != nullptr)
		*Out_Sounds = std::move(Parms.Out_Sounds);
}


// Function B_WeaponSoundLibraryComponent.B_WeaponSoundLibraryComponent_C.OnModApplied
// (Event, Protected, BlueprintEvent)
// Parameters:
// const class UFortWeaponModAudioData*    InModAudioData                                         (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UB_WeaponSoundLibraryComponent_C::OnModApplied(const class UFortWeaponModAudioData* InModAudioData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_WeaponSoundLibraryComponent_C", "OnModApplied");

	Params::B_WeaponSoundLibraryComponent_C_OnModApplied Parms{};

	Parms.InModAudioData = InModAudioData;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_WeaponSoundLibraryComponent.B_WeaponSoundLibraryComponent_C.OnModRemoved
// (Event, Protected, BlueprintEvent)
// Parameters:
// const class UFortWeaponModAudioData*    InModAudioData                                         (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UB_WeaponSoundLibraryComponent_C::OnModRemoved(const class UFortWeaponModAudioData* InModAudioData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_WeaponSoundLibraryComponent_C", "OnModRemoved");

	Params::B_WeaponSoundLibraryComponent_C_OnModRemoved Parms{};

	Parms.InModAudioData = InModAudioData;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_WeaponSoundLibraryComponent.B_WeaponSoundLibraryComponent_C.OnSoundPlayed
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              InEventName                                            (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// class UAudioComponent*                  InComponent                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UB_WeaponSoundLibraryComponent_C::OnSoundPlayed(const struct FGameplayTag& InEventName, class UAudioComponent* InComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_WeaponSoundLibraryComponent_C", "OnSoundPlayed");

	Params::B_WeaponSoundLibraryComponent_C_OnSoundPlayed Parms{};

	Parms.InEventName = std::move(InEventName);
	Parms.InComponent = InComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_WeaponSoundLibraryComponent.B_WeaponSoundLibraryComponent_C.OnSoundStopped
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              InEventName                                            (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// class UAudioComponent*                  InComponent                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool*                                   bStopped                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UB_WeaponSoundLibraryComponent_C::OnSoundStopped(const struct FGameplayTag& InEventName, class UAudioComponent* InComponent, bool* bStopped)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_WeaponSoundLibraryComponent_C", "OnSoundStopped");

	Params::B_WeaponSoundLibraryComponent_C_OnSoundStopped Parms{};

	Parms.InEventName = std::move(InEventName);
	Parms.InComponent = InComponent;

	UObject::ProcessEvent(Func, &Parms);

	if (bStopped != nullptr)
		*bStopped = Parms.bStopped;
}


// Function B_WeaponSoundLibraryComponent.B_WeaponSoundLibraryComponent_C.ReceiveBeginPlay
// (Event, Public, BlueprintEvent)

void UB_WeaponSoundLibraryComponent_C::ReceiveBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_WeaponSoundLibraryComponent_C", "ReceiveBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_WeaponSoundLibraryComponent.B_WeaponSoundLibraryComponent_C.SetBaseMS
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UB_WeaponSoundLibraryComponent_C::SetBaseMS()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_WeaponSoundLibraryComponent_C", "SetBaseMS");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_WeaponSoundLibraryComponent.B_WeaponSoundLibraryComponent_C.SetModMS
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UB_WeaponSoundLibraryComponent_C::SetModMS()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_WeaponSoundLibraryComponent_C", "SetModMS");

	UObject::ProcessEvent(Func, nullptr);
}


// Function B_WeaponSoundLibraryComponent.B_WeaponSoundLibraryComponent_C.TryHandleFireEvent
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              Event                                                  (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// class UAudioComponent*                  Component                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UB_WeaponSoundLibraryComponent_C::TryHandleFireEvent(const struct FGameplayTag& Event, class UAudioComponent* Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_WeaponSoundLibraryComponent_C", "TryHandleFireEvent");

	Params::B_WeaponSoundLibraryComponent_C_TryHandleFireEvent Parms{};

	Parms.Event = std::move(Event);
	Parms.Component = Component;

	UObject::ProcessEvent(Func, &Parms);
}


// Function B_WeaponSoundLibraryComponent.B_WeaponSoundLibraryComponent_C.ValidateModMetasounds
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          OnepMetaSoundPatch                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UObject*                          ThreepMetaSoundPatch                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool*                                   bShouldBuild                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UB_WeaponSoundLibraryComponent_C::ValidateModMetasounds(class UObject* OnepMetaSoundPatch, class UObject* ThreepMetaSoundPatch, bool* bShouldBuild)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("B_WeaponSoundLibraryComponent_C", "ValidateModMetasounds");

	Params::B_WeaponSoundLibraryComponent_C_ValidateModMetasounds Parms{};

	Parms.OnepMetaSoundPatch = OnepMetaSoundPatch;
	Parms.ThreepMetaSoundPatch = ThreepMetaSoundPatch;

	UObject::ProcessEvent(Func, &Parms);

	if (bShouldBuild != nullptr)
		*bShouldBuild = Parms.bShouldBuild;
}

}

